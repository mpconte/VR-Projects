<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>BlueScript: A Quick Introduction</title>
    <link rel="stylesheet" type="text/css" href="bluescript.css">
  </head>

  <body>
    <h1>BlueScript: A Quick Introduction</h1>

    <hr />
      <p><i><a href="index.html">Return to index</a></i></p>


      <h2>Basic Elements</h2>
      
      <h3>Strings</h3>

      <p>The fundamental unit of BlueScript is the string.  A string that
	does not contain spaces or special characters (defined later) can
	be represented without any special treatment.  For example:
	<div class="eg">
	  Hello
	</div>
	represents the string "Hello".
      </p>
      
      <p>A string generally ends at the first white-space character.
	If you wish to include whitespace in a string, you can use
	the escape character '\' to force BlueScript to treat the
	white-space character as being "non-special".  For example:
	<div class="eg">
	  Hello\ World!
	</div>
	represents the string "Hello World!".
      </p>
      
      <p>White-space can also be included in a string using <em>quoting</em>.
	There different forms of quoting.  Given these examples:
	<div class="eg">
	  "Hello World!"<br />
	    {Hello World!}
	</div>
	Both of these examples represent the string "Hello World!".  There
	are side-effects to using quotes which are described below.
      </p>

      <p>A string that is specified without quotes is also referred to
	as a <em>constant string</em> or <em>static string</em>.  For
	example, the following examples:
	<div class="eg">
	  Hello<br />
	    Hello\ World<br />
	</div>
	are constant strings.
      </p>

      <h3>Integers</h3>
      
      <p>Sometimes strings are interpreted as integers.  Integers may
	be represented by any of the standard C forms, e.g. decimal
	<div class="eg">
	  123510, -15
	</div>
	or hexadecimal (if preceded by "<code>0x</code>" or "<code>0X</code>")
	<div class="eg">
	  0x1234, 0X5abC3f
	</div>
	or octal (if preceded by "<code>0</code>")
	<div class="eg">
	  0177, 0253
	</div>
      </p>

      <h3>Floating-Point</h3>

      <p>Sometimes strings are interpreted as floating-point numbers.
	Floating-point numbers may be represented by any of the
	standard C forms, e.g.
	<div class="eg">
	  1.1023, 6.0e10, -4.123823E-5
	</div>
      </p>

      <h3>Lists</h3>
      <p>Any string can be interpreted as a list.  The elements of a list
	are assumed to be separated by white-space.  For example:
	<div class="eg">
	  "Hello there &nbsp; world!"
	</div>
	can be interpreted as a list with three elements: "Hello",
	"there" and "world!".  Note that there can be any number of
	white-space characters between elements of a list; extra
	white-space characters are ignored.</p>
      <p>To define more complex lists, or to include elements in the
	list that contain white-space, we can use list quoting
	operators.  For example, the following:
	<div class="eg">
	  {Hello there &nbsp; world!}
	</div>
	represents the same list: "Hello", "there" and "world!".
	However, unlike other operators, we can use the list quoting
	operator to nest lists.  For example, the following:
	<div class="eg">
	  {Hello there {} world!}
	</div>
	is a list with four elements:  "Hello", "there", "" (an empty
	string) and "world!".  A more complex example:
	<div class="eg">
	  {{This is the first element} {This is the second} {And third!}}
	</div>
	shows a list of three elements, where each element of the list
	can also be interpreted as a list.
      </p>
      <p>Lists defined with list quotes are referred to as
	<em>constant lists</em> or <em>static lists</em>.  Any
	list can also be considered as a string.  The string
	representation of a list is generated by concatenating the 
	elements of a string together with a single space character
	in between each element.
      </p>

      <h3>Variables</h3>
      <p>
	So far, everything we have described has been static.  The
	BlueScript environment also defines <em>variables</em> which (as
	in other languages) are objects that contain values.  We can
	specify the the value of a string is not a static value, but is
	instead the value contained in a variable using the '$'
	character.  For example, the value of the following string:
	<div class="eg">
	  $holder
	</div>
	is the contents of the variable called "holder".  Using the
	syntax, the variable name must satisfy the following:
	<ul>
	  <li>The name must being with an alphabetic character ('A-Z'
	    or 'a-z') or an underscore ('_').</li>
	  <li>The name must contain only alphabetic characters ('A-Z'
	    or 'a-z'), decimal digits ('0-9') and underscores ('_').
	</ul>
      </p>

      <p>An alternate
	syntax uses the '{' and '}' quotes to surround the name of the
	variable, for example:
      <div class="eg">
	${holder}
      </div>
	has the same meaning as the previous example.  This syntax
	does not limit the types of variable names that can be created.
      </p>
      <p>Anywhere we can use a string, we can generally replace it
	with a variable reference.  However, we cannot replace a
	substring with a variable reference without using a string
	constructor (see below).  For example, the following:
	<div class="eg">
	  ${var}string
	</div>
	is illegal on its own.  It may be made valid by using the
	string constructor quotes.  For example, the following:
	<div class="eg">
	  "${var}string"
	</div>
	is legal.  See the discussion below on string constructors for
	more detail.
      </p>

      <h3>Commands</h3>
      <p>
      BlueScript code (referred to as a <em>script</em>) is a sequence
      of commands.  A command is an unquoted list then ends with a
      newline character.  For example:
      <div class="eg">
	cmdname arg1 arg2 arg3
      </div>
      This would invoke the procedure "cmdname" with three arguments
      "arg1", "arg2" and "arg3".
      </p>
      <p>
	A command may span multiple lines if the newline character is
	either escaped (using the '\' character) or is contained in
	quotes (e.g. '""' or '{}').  For example:
	<div class="eg">
<pre>foreach x {1 2 3} {
    set y $x
    set z [expr $y + $y]
}</pre>
	</div>
	is a single command even though it is spread across four
	lines.
      </p>
      
      <h3>Evaluation Lists</h3>
      <p>
      The evaluation quotes ('[' and ']') specify a list that is to be
      treated like a command.  When it is evaluation, an evaluation
      list is replaced with the result of executing a command.
      For example, given:
      <div class="eg">
	cmdname [foo bar] x
      </div>
      would call the command "cmdname" with two arguments.  The first
      argument would be the result of evaluating the command "foo"
      with the argument "bar" and the second argument to "cmdname"
      would be "x".
      </p>
      
      <h3>String Constructors</h3>
      <p>
	The string quotes ('"') are actually string constructors.
	That is, they allowed the substitution of variable references and
	evaluation lists to construct strings.  For example, the following:
	<div class="eg">
	  "Hello there, ${joe}.  How do you like [gethostname]?"
	</div>
	will evaluate to a string, but "${joe}" will be replaced with
	the value of the variable "joe" and "[gethostname]" will be
	replaced with the result of evaluating the procedure "gethostname".
      </p>
      
      <h2>Evaluating a Command</h2>
      <p>
	A command is evaluated as follows:
	<ol>
	  <li>Each element of the command list (including the command
	    name) is prepared as follows:
	    <ul>
	      <li>If the element is a constant string or constant list
		it is left unchanged.</li>
	      <li>If the element is a variable reference, then it is
		replaced by the value of that variable.</li>
	      <li>If the element is an evaluation list, then it is 
		replaced by the result of evaluating the contained
		command.</li>
	      <li>If the element is a string constructor, then it is
		replaced by the constructed string.  Note that this
		means that any variable references or evaluation lists
		within the string constructor will also be
		evaluated.</li>
	      </ul>
	    </li>
	  <li>The interpreter locates the appropriate procedure and
	    invokes it, passing the evaluated arguments to it.
	  </li>
	  <li>Upon completion, a procedure generates a result (which
	    is left in the interpreter's result buffer) or generates
	    an error.  An error causes an exception, which interrupts
	    execution of the script.
	  </li>
	</ol>
      </p>
      <p>When evaluating a command its arguments are passed as
	values.  For example, after executing the following code:
<div class="eg">
<pre>proc square {x} {
    set x [expr $x * $x]
    return $x
}

set x 10
set y [square $x]</pre>
</div>
	The value of "$x" will be "10" and the value of "$y" will be
	100.  The procedure <code>square</code> does not modify the
	value of "x" that is passed to it.
      </p>
      <p>There is an important exception to the "pass-by-value" rule
	which involves <em>opaque objects</em> (see below).</p>

      <h2>Opaque Objects</h2>

      <p>Since BlueScript is meant to be an embedded scripting language it
	needs to be able to interact with and manipulate objects which
	many not be easily represented by any of the above models.  To
	this end, BlueScript can handle <em>opaque objects</em>.  As
	the name implies, an opaque object is one that BlueScript
	knows nothing about it.  That is, it cannot be completely 
	represented as a literal value (i.e. as a string).  Thus it
	cannot be passed around as a value.  Instead, an opaque object
	is passed around as a reference.</p>
      <p>A reference to an opaque object is always contained in a
	variable. For example, there are standard functions in
	BlueScript that represent files and other data sources and
	sinks as <em>streams</em>.  (See the "Standard BlueScript
	Reference" for more details on streams and stream functions.)
	An optional procedure "<code>stdout</code>" returns a
	reference to stream corresponding to the standard output.  For
	example:
	<div class="eg">
	  set x [stdout]
	</div>
	would store a reference to the standard output stream object 
	in the variable "x".
      </p>
      <p>An opaque object can be manipulated in one of two ways:
	<ul>
	  <li>It can be passed as an argument to a procedure that can
	    work with opaque objects.</li>
	  <li>An opaque object's <em>method</em> may be invoked.</li>
	</ul>
	A <em>method</em> is a procedure that is associated with an
	opaque object itself.  This is a simplistic form of
	object-oriented programming.  If an opaque object supports
	methods, then the opaque object reference can itself be used
	as a command name, which should then be followed by the name
	of the method and any arguments to the method.
      </p>
      <p>Methods are easier to understand by example.  A stream object
	implements a number of methods, including one called 
	"<code>writeln</code>".  This method takes one argument which
	is interpreted as a string and then written to the given
	stream followed by a new-line character.  For example, the following:
	<div class="eg">
	  [stdout] writeln "Hello, World!"
	</div>
	would write the string "Hello, World!" followed by a new-line
	to the <code>stdout</code> stream.  Since we can store a
	reference in a variable, we could also code this as:
<div class="eg">
<pre>set x [stdout]
$x writeln "Hello, World!"</pre>
</div>
      </p>
      <p>Note that opaque objects are always represented as
	references.  So if we were to copy a stream object as follows:
	<div class="eg">
	  set x [stdout]<br />
	    set y $x
	</div>
	then the variables "x" and "y" both refer to the same stream
	object, since what is stored in "y" is a copy of the reference
	that is stored in "x".
      </p>
      <p>This "pass-by-reference" behaviour for opaque objects is also
	used when an opaque object is an argument to a command.  For
	example, in the following:
<div class="eg">
<pre>proc write_hello {s} {
    $s writeln "Hello, World!"
}
write_hello [stdout]</pre>
</div>
	The "stdout" stream is passed as a reference to the
	"write_hello" command.  This means that the variable "s" in
	the "write_hello" command refers to same object as the result
	of "[stdout]".
      </p>

      <h2>Expressions</h2>
      
      <p>It is a common case for commands to make use of infix
	mathematical or logical expressions.  To this end, BlueScript
	includes a common expression engine.</p>
      <p>Expressions use values as operands.  A value can be
	represented as:
	<ul>
	  <li>a string</li>
	  <li>a variable reference</li>
	  <li>an evaluation list</li>
	  <li>a function (see below)</li>
	</ul>
	All values are reduced to the most appropriate of the
	following types:
	<ul>
	  <li>string</li>
	  <li>integer</li>
	  <li>floating-point value</li>
	</ul>
	At times it is useful to interpret a value as a Boolean
	true-or-false value.  In these cases, all possible values are
	considered to be "true" except for the following:
	<ul>
	  <li>an empty string</li>
	  <li>the integer 0</li>
	  <li>the floating-point value 0.0</li>
	</ul>
	which are all considered to be false.
      </p>
      <p>The following operators are supported:
	<p align="center">
	<table class="realtable">
	  <tr><th>Op</th><th>Operand Type</th><th>Description</th></tr>
	  <tr><td>&&</td><td>Boolean</td><td>Logical "and"</td></tr>
	  <tr><td>||</td><td>Boolean</td><td>Logical "or"</td></tr>
	  <tr><td>!</td><td>Boolean</td><td>Logical "not"</td></tr>
	  <tr><td>==</td><td>any</td><td>Equality</td></tr>
	  <tr><td>!=</td><td>any</td><td>Inequality</td></tr>
	  <tr><td>&lt;</td><td>any</td><td>Less-than</td></tr>
	  <tr><td>&lt;=</td><td>any</td><td>Less-than-or-equal</td></tr>
	  <tr><td>&gt;</td><td>any</td><td>Greater-than</td></tr>
	  <tr><td>&gt;=</td><td>any</td><td>Greater-than-or-equal</td></tr>
	  <tr><td>+</td><td>int or float</td><td>Addition</td></tr>
	  <tr><td>-</td><td>int or float</td><td>Subtraction (binary)
	      or negation (unary)</td></tr>
	  <tr><td>*</td><td>int or
	      float</td><td>Multiplication</td></tr>
	  <tr><td>/</td><td>int or float</td><td>Division</td></tr>
	  <tr><td>%</td><td>int</td><td>Modulus</td></tr>
	</table>
	  </p>
	Operator precedence is the same as in Standard C.
	In addition, parentheses ("(" and ")") can be used to group
	together sub-expressions and override precedence.
      </p>
      <p>When evaluating an operator, the expression engine always
	attempts to make the types of both operands correspond.  If
	the operator has no specific requirements, then the following
	steps are taken:
	<ul>
	  <li>If either operand is a float, convert both to float</li>
	  <li>If either operand is an int, convert both to int</li>
	  <li>Treat both as strings</li>
	</ul>
	Functions may be used to force a value to be a particular type
	(see the second on function below).
      </p>
      
      <h3>Functions</h3>
      <p>There are a special set of <em>functions</em> that may be
	used in expressions.  A function takes 0 or more arguments.
	The following arguments are currently defined:</p>
      
      <dl>
	<dt><b>int(</b><i>x</i><b>)</b></dt>
	<dd>Force the value <i>x</i> to be interpreted as an int.
	  If it cannot, then an error is generated.
	</dd>
	<dt><b>float(</b><i>x</i><b>)</b></dt>
	<dd>Force the value <i>x</i> to be interpreted as a float.
	  If it cannot, then an error is generated.
	</dd>
	<dt><b>string(</b><i>x</i><b>)</b></dt>
	<dd>Force the value <i>x</i> to be interpreted as a
	  string.</dd>
	<dt><b>boolean(</b><i>x</i><b>)</b></dt>
	<dd>Convert the given value to the integer "0" if it is
	  a boolean false value, or the integer "1" otherwise.</dd>
      </dl>
	
  </body>
</html>
