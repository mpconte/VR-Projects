<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>VE Input Concepts</title>
    <link rel="stylesheet" type="text/css" href="ve.css">
  </head>

  <body>
    <h1>VE Input Concepts</h1>
    <hr />

      <p><a href="index.html"><i>Back to the index</i></a></p>

      <h2>Devices</h2>
      <p>
	Input is generated by <em>devices</em>, such as a joystick or
	a keyboard.  A device is comprised of a set of
	<em>elements</em>.  An element is a simple piece of a device.
	Each element type can also generate events of the same type.
	For example, a switch element can generate switch events.
	These events communicate state changes to the application.
	The following elements (and events) are defined:
      </p>
      <dl>
	<dt><code>trigger</code></dt>
	<dd>
	  A trigger is an element that has no state information
	  associated with it.  A trigger event indicates that
	  something happened but does not associate that "something"
	  with any specific state change or value.  A trigger is the
	  simplest element.
	</dd>
	<dt><code>switch</code></dt>
	<dd>
	  A switch is an element that exists in either an "on" or
	  "off" state (sometimes referred to as "down" and "up"
	  respectively).  Switch events indicate a transition from
	  one state to the other.  Switches often represent physical
	  input devices like buttons on gamepads and joysticks.
	</dd>
	<dt><code>keyboard</code></dt>
	<dd>
	  <p>
	    A keyboard is a special case of a switch.  It is (in
	    effect) an unspecified array of switches.  Each individual
	    switch has the same "on" and "off" states as a regular
	    switch but each keyboard event has a <i>keycode</i>
	    associated with it to identify the key to which this event
	    pertains.
	  </p>
	  <p>Keyboards are not often defined as elements, but are
	    more often just used as events.</p>
	</dd>
	<dt><code>valuator</code></dt>
	<dd>
	  A valuator is an element that has a floating-point value
	  associated with it.  The value may be bounded (i.e. be
	  associated with a range of possible values specified by
	  minimum and maximum values) or unbounded (i.e. there are
	  no specified limitations on the range of possible
	  values).  Valuators typically represent input elements
	  that have continuous (or seemingly continuous) values, e.g.
	  a joystick axis.
	</dd>
	<dt><code>vector</code></dt>
	<dd>
	  A vector is, in effect, a multi-dimensional valuator.  A
	  vector contains <i>n</i> floating-point values in an array.  (The
	  value of <i>n</i> can vary and depends upon the specific
	  vector.)  As in a valuator, each value in the vector may
	  be either bounded or unbounded.  Vectors are used to
	  represent continuous values that should be associated
	  together.  For example, a head-tracker may generate a
	  sequence of positions (as a 3-dimensional vector) and
	  quaternions (as a 4-dimensional vector).  In these types
	  of cases, it is preferrable to report changes to the
	  entire vector, rather than reporting a separate change for
	  each individual dimension of the vector.
	</dd>
      </dl>

      <h2>Events</h2>
      <p>
	Input to the VE library and VE applications consists of a 
	sequence of <em>events</em>.
	An event represents a single change of the input state.
	An event is identified by a combination of the <em>device</em>
	that generated the event and the <em>element</em> of the
	device from which it originated.  This name is usually
	written in a dotted notation:
	<div class="eg">
	  <i>device</i>.<i>element</i>
	</div>
      </p>
      <p>
	In many instances we wish to limit the set of events a
	particular component of the system deals with by using an
	<em>event specifier</em>.  For the following examples, we will
	consider a device called <code>joystick</code> with the
	following elements:
	<ul>
	  <li><code>x</code> - a valuator (representing the horizontal
	    position of the stick</li>
	  <li><code>y</code> - a valuator (representing the vertical
	    position of the stick</li>
	  <li><code>b0</code> - a switch (the first button)</li>
	  <li><code>b1</code> - a switch (the second button)</li>
	</ul>
      </p>
      <p>
	The simplest type of event specifier is a <em>fixed
	  specifier</em>.  This identifies a specific device and
	element combintation.  As such, it is simply written using the
	device name and element name.  For example:
	<div class="eg">
	  joystick.x
	</div>
	is an event specifier that matches events originating from the
	<code>x</code> element of the device <code>joystick</code>.
      </p>
      <p>
	The '*' character may be used as a wildcard for either of the
	device or element components of a specifier.  For example:
	<div class="eg">
	  joystick.*
	</div>
	is an event specifier that matches any event that originates
	from the <code>joystick</code> device regardless of which
	element generated the event.  So this would match events from
	elements <code>x</code>, <code>y</code>, <code>b0</code> and
	<code>b1</code>.
      </p>
      <p>
	This wildcard may also be used on the device side.  For
	example:
	<div class="eg">
	  *.x
	</div>
	would match all events generated by elements called
	<code>x</code> regardless of the device from which the element
	came.
      </p>
      <p>
	Note that the wildcard cannot be embedded in a name so usage
	such as <code>joystick*.b0</code> is illegal.
      </p>
      <p>
	All events have an associated payload which contains the
	state that the element has entered.  For example, when 
	button <code>b0</code> is pushed down then an event called
	<code>joystick.b0</code> is generated with a state of "1" (to
	indicate a "down" or "on" state).  When button <code>b0</code>
	is released then an event also called <code>joystick.b0</code>
	is generated with a state of "0".
      </p>

      <h3>Virtual Events</h3>
      <p>
	VE does not require that events be generated solely by real
	devices.  For example, given a event with the name:
	<div class="eg">
	  phony.button912
	</div>
	VE does not care if the device <code>phony</code> actually
	exists.  Even if <code>phony</code> exists but does not have
	an element called <code>button912</code>, this is still not a
	problem.  If the above event is injected into VE's event
	processing code, it will still handle it.  It is even valid
	for an event to match an existing device and element but have
	a different type than the element.  For example, given the
	joystick example of the previous section, an event may be
	called <code>joystick.x</code> but have a <code>switch</code>
	type.  Events which do not mesh with an actual device and
	element are referred to as <em>virtual events</em>.  Virtual
	events are of particular use in implementing "virtual devices"
	which is a strategy that is discussed later.  For now, it is
	important to understand that the naming scheme for events is
	just that - a scheme.  It does not require that the device or
	element be real.
      </p>

      <h2>Event Processing</h2>

      <div class="figure">
	<img src="eventproc.jpg" alt="Event Processing" />
	  <div class="caption">
	    Events are generated by devices (or optionally by the
	    application itself) and are processed by the filter
	    table.  Once filter table processing has complete,
	    depending upon the outcome of the last filter that was
	    executed, the event is either delivered to an application
	    callback or is discarded.
	  </div>
      </div>
      <p>
	Once an event is generated, either by a real device or
	optionally, by the application code itself, it is processed by
	the <em>filter table</em>.  The filter table contains a set of
	<em>filters</em> which are actions that are taken on events
	(depending upon the name of the event) which may modify the
	event, redirect it (by renaming it), discard it or generate
	entirely new events.  Filters are special in that they are
	defined at run-time rather than compile-time.  That is,
	filters may be changed without recompiling the application.
	Filters and the filter table are discussed in greater detail
	below.
      </p>
      <p>
	Once filter table processing has completed, the outcome of
	processing will be to either discard the event - meaning that
	the event is destroyed and no further action is taken - or the
	event is delivered to the application.  Applications deal with
	events by registering one or more <em>callbacks</em>.
	Applications can use event specifiers to indicate which events
	callbacks are interested in.  If an application has no
	callback registered for a particular event, then it is as
	though the event was discarded, i.e. the event is ignored.
	In callbacks, applications can implement the effects of an
	event - that is, they can use events to cause changes in the
	environment, move the user, etc.
      </p>
      
      <h3>Filters</h3>
      <p>
	A filter is a script that is executed when a particular event
	type is generated.  Filters are written in 
	<a href="bluescript.html">BlueScript</a> which is an embedded
	scripting language.  Events are represented as opaque objects.
	Full details on what methods are supported in filters can be
	found in the <a href="veblue.html">VE BlueScript Reference</a>.
      </p>

  </body>
</html>
