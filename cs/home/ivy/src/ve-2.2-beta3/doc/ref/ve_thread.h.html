<html>
<head>
<title>File: ve_thread.h</title>
</head>
<body>
<h1 class="cdoc-file">File: ve_thread.h</h1>
<h2 class="cdoc-contents">Contents</h2>
<ul>
<li class="cdoc-centry"><a href="#sect_0" class="link-section"><span class="text-section">Thread-Specific Data</span></a></li>
</ul>


<p class="cdoc-item">
    <p>The ve_thread module provides an abstract interface for working
    with threads.  Much of this is targetted towards the library itself
    but can also be used by applications based upon the library.</p>
    <p>Most of the types used in this module should be considered
    opaque and should only be generated by calls to the library.
    The <i>ve_thread_sys</i> module has more on the cross-platform nature
    of the thread support.</p>
    <p>Since this module is meant as support to the rest of the library,
    any reference to the "application" in the documentation can be taken
    to mean any code, program, or library which calls this module.  The
    "current thread" refers to the thread that calls the given function.</p>

<p class="cdoc-item">
<a name="function_veThrBarrierCreate"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrBarrierCreate</span>
<div class="body-function">
<div class="codeblock">VeThrBarrier *veThrBarrierCreate(int size);</div>    Creates a barrier.  A barrier will stop all threads as they enter the 
    barrier and will only let them go once a particular number of threads
    have arrived.
    
<div class="start-param"><span class="tag-param">size</span> - 
    The number of threads that must arrive in the barrier before the
    threads are released.  This number is fixed for a given barrier -
    it cannot be changed once the barrier is created.</div>
<div class="start-returns"><span class="label-returns">Returns:</span> 
    A pointer to a newly allocated barrier.  This barrier must be
    destroyed with <code>veThrBarrierDestroy()</code> in order to free
    the memory associated with the barrier.
 </div></div></div>
<p class="cdoc-item">
<a name="function_veThrBarrierDestroy"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrBarrierDestroy</span>
<div class="body-function">
<div class="codeblock">void veThrBarrierDestroy(VeThrBarrier *b);</div>    Destroys a barrier and deallocates its associated resources.  It is up
    to the application to ensure that there are no threads in the barrier
    when it is destroyed.
    
<div class="start-param"><span class="tag-param">b</span> - 
    A pointer to the barrier to be destroyed.  This barrier must have
    been generated by a call to <code>veThrBarrierCreate()</code>.</div></div></div>
<p class="cdoc-item">
<a name="function_veThrBarrierEnter"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrBarrierEnter</span>
<div class="body-function">
<div class="codeblock">void veThrBarrierEnter(VeThrBarrier *b);</div>    Causes the current thread to enter the specified barrier.  Once the
    thread enters the barrier it will block until the barrier has filled
    with threads (determined by the barrier's size).  Once the barrier
    has filled, all threads in the barrier will be released.  This
    function does not return until the threads are released.

<div class="start-param"><span class="tag-param">b</span> - 
    A pointer to the barrier to enter.  This barrier must have been
    generated by a call to <code>veThrBarrierCreate()</code>.</div></div></div>
<p class="cdoc-item">
<a name="function_veThreadCreate"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThreadCreate</span>
<div class="body-function">
<div class="codeblock">VeThread *veThreadCreate();</div>    Creates a new thread object.  Note that the thread is not active
    until it has been initialized by a call to <code>veThreadInit</code>.
    
<div class="start-returns"><span class="label-returns">Returns:</span> 
    A pointer to the newly created thread object.  This object must be
    disposed of by calling <code>veThreadDestroy</code> to release its
    associated resources.</div></div></div>
<p class="cdoc-item">
<a name="function_veThreadId"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThreadId</span>
<div class="body-function">
<div class="codeblock">int veThreadId(void);</div>    Attempts to determine a unique identifier for the current thread.
    This should only be used for debugging reporting - it may not
    work properly on all platforms.

<div class="start-returns"><span class="label-returns">Returns:</span> 
    An integer identifying the current thread,if possible.</div></div></div>
<p class="cdoc-item">
<a name="function_veThreadInit"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThreadInit</span>
<div class="body-function">
<div class="codeblock">int veThreadInit(VeThread *t, void *(*func)(void *), void *arg, int priority,
		 int flags);</div>    <p>Initializes a thread.  After this call, the thread will begin to
    execute code starting at the specified function.  A priority may
    be specified - higher values indicate threads that run at a higher
    priority.</p>

<div class="start-param"><span class="tag-param">t</span> - 
    A pointer to the thread object to initialize.  If this value is 
    <code>NULL</code> then an anonymous thread will be created.  That is,
    the thread will exist and run, but there will be no <code>VeThread</code>
    structure attached to it.  Such a thread cannot be controlled via the 
    <code>VeThreadKill()</code> and <code>VeThreadWait()</code> calls.</div>
<div class="start-param"><span class="tag-param">func</span> - 
    The function at which the thread will start execution.  Upon returning
    from this function, the thread will stop execution.  This function should
    take a single <code>void *</code> argument.</div>
<div class="start-param"><span class="tag-param">arg</span> - 
    The argument which will be passed to the function <code>func</code>.
    </div>
<div class="start-param"><span class="tag-param">priority</span> - 
    A non-negative priority to assign this thread.  Higher values indicate
    a higher priority.  If the specified priority exceeds system values,
    then the value will be clamped.  An implementation may choose to ignore
    specified thread priorities and run all threads at the same priority.
    Hence, this argument is purely advisory.</div>
<div class="start-param"><span class="tag-param">flags</span> - 
    The bitwise-or of a number of possible option flags.  Currently, only
    the <code>VE_THR_KERNEL</code> flag is defined.  By default, the 
    thread system will
    tend towards creating user-level threads.  If <code>VE_THR_KERNEL</code> 
    is specified then the system will attempt to create a kernel-level thread.
    Kernel-level threads have more overhead associated
    with them, but tend to have better scheduling
    characteristics, particularly on multi-processor systems.  Kernel-level
    threads may not be supported on some platforms and may be the default
    on others.  Hence, this option is advisory, but every effort is made
    to honour it.
 </div></div></div>
<p class="cdoc-item">
<a name="function_veThreadDestroy"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThreadDestroy</span>
<div class="body-function">
<div class="codeblock">void veThreadDestroy(VeThread *t);</div>    Destroys a thread and deallocates its associated resources.  It 
    is up to the application to ensure that the thread has finished
    execution before calling this function.
    
<div class="start-param"><span class="tag-param">t</span> - 
    A pointer to the thread to destroy.</div></div></div>
<p class="cdoc-item">
<a name="function_veThreadKill"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThreadKill</span>
<div class="body-function">
<div class="codeblock">void veThreadKill(VeThread *t);</div>    Forcibly halts execution of a thread.  There are no guarantees
    that the thread has left its context in a meaningful state. 
    Any application which terminates a thread in this fashion should
    be prepared to clean up anything it leaves behind.  After returning
    from this call, the specified thread is no longer active.

<div class="start-param"><span class="tag-param">t</span> - 
    The thread to kill.</div></div></div>
<p class="cdoc-item">
<a name="function_veThreadWait"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThreadWait</span>
<div class="body-function">
<div class="codeblock">void veThreadWait(VeThread *t);</div>    Stops the current thread until the specified thread has finished
    execution.  Upon return from this function, the specified thread
    is no longer executing code and may either be destroyed or
    re-initialized.

<div class="start-param"><span class="tag-param">t</span> - 
    The thread to wait on.</div></div></div>
<p class="cdoc-item">
<a name="function_veThrMutexCreate"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrMutexCreate</span>
<div class="body-function">
<div class="codeblock">VeThrMutex *veThrMutexCreate();</div>    Creates a mutex.  A mutex is a lock that can be held by at most
    one thread at a time.  In its initial state, no thread holds
    the mutex.

<div class="start-returns"><span class="label-returns">Returns:</span> 
    A pointer to the newly created mutex.</div></div></div>
<p class="cdoc-item">
<a name="function_veThrMutexDestroy"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrMutexDestroy</span>
<div class="body-function">
<div class="codeblock">void veThrMutexDestroy(VeThrMutex *m);</div>    Destroys a previously created mutex.  It is up to the application
    to ensure that it is safe to destroy the mutex - i.e. that at
    most the current thread is holding the mutex and that no threads
    attempt any operations upon this mutex after destroying it.

<div class="start-param"><span class="tag-param">m</span> - 
    The mutex to destroy.</div></div></div>
<p class="cdoc-item">
<a name="function_veThrMutexLock"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrMutexLock</span>
<div class="body-function">
<div class="codeblock">void veThrMutexLock(VeThrMutex *m);</div>    <p>Locks a mutex with the current thread.  If the mutex is being held 
    by another thread then the current thread will stop until there
    are no other threads holding the mutex and it can lock it.  When the
    function returns, the current thread is holding the mutex.  When
    a thread holds a mutex, no other thread can hold it, and other threads
    will stop if they attempt to lock this mutex.</p>
    <p>Recursive locks (i.e. attempting to lock a mutex when the current
    thread has already locked it) are not supported.  The effects of a
    recursive lock are undefined.</p>

<div class="start-param"><span class="tag-param">m</span> - 
    The mutex to lock.</div></div></div>
<p class="cdoc-item">
<a name="function_veThrMutexUnlock"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrMutexUnlock</span>
<div class="body-function">
<div class="codeblock">void veThrMutexUnlock(VeThrMutex *m);</div>    <p>Unlocks a mutex.  The current thread must hold the mutex.
    When the function returns, the specified mutex is no longer held
    by the current thread.  It may or may not be held by another thread.
    </p>
    
<div class="start-param"><span class="tag-param">m</span> - 
    The mutex to unlock.</div></div></div>
<p class="cdoc-item">
<a name="function_veThrCondCreate"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrCondCreate</span>
<div class="body-function">
<div class="codeblock">VeThrCond *veThrCondCreate();</div>    <p>Creates a condition variable.  A condition variable is an object
    upon which a thread can wait.  A thread will be woken up if the
    event associated with a condition variable occurs.  In its
    initial state, there are no threads waiting upon a condition variable.</p>
    
<div class="start-returns"><span class="label-returns">Returns:</span> 
    A pointer to the newly-created condition variable.</div></div></div>
<p class="cdoc-item">
<a name="function_veThrCondDestroy"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrCondDestroy</span>
<div class="body-function">
<div class="codeblock">void veThrCondDestroy(VeThrCond *c);</div>    <p>Destroys a condition variable previously created with
    <code>veThrCondCreate</code>.  It is up to the application to ensure
    that it is safe to destroy the condition variable, i.e. that there are
    no threads waiting on the condition variable.</p>
    
<div class="start-param"><span class="tag-param">c</span> - 
    The condition variable to destroy.</div></div></div>
<p class="cdoc-item">
<a name="function_veThrCondWait"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrCondWait</span>
<div class="body-function">
<div class="codeblock">void veThrCondWait(VeThrCond *c, VeThrMutex *m);</div>    <p>Waits upon a condition variable.  The current thread will stop until
    the event associated with a condition variable takes place.</p>
    <p>A mutex is usually associated with a condition variable.  There
    must be <i>a</i> mutex held by the current thread before calling this
    function.  Precisely <i>which</i> mutex is up to the application.
    Upon entering this function, the mutex will be unlocked while the 
    current thread is stopped.  When the thread is woken up it will lock
    the mutex again.
    </p>

<div class="start-param"><span class="tag-param">c</span> - 
    The condition variable to wait upon.
    </div>
<div class="start-param"><span class="tag-param">m</span> - 
    The mutex associated with this condition variable.  The current
    thread must be holding this mutex.  The mutex will be unlocked
    while the thread is waiting and will be locked again once it
    finishes waiting.</div></div></div>
<p class="cdoc-item">
<a name="function_veThrCondTimedWait"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrCondTimedWait</span>
<div class="body-function">
<div class="codeblock">void veThrCondTimedWait(VeThrCond *c, VeThrMutex *m, long ms);</div>    <p>Similar to <code>veThrCondWait</code> except that a time-limit
    is put upon how long the thread will wait on the given condition
    variable.  If the time-limit is reached before the event associated
    with the condition variable occurs, then the thread will be re-lock 
    the given mutex and return.</p>

<div class="start-param"><span class="tag-param">c</span> - 
    The condition variable to wait upon.</div>
<div class="start-param"><span class="tag-param">m</span> - 
    The mutex associated with this condition variable.  The current
    thread must be holding this mutex.  The mutex will be unlocked
    while the thread is waiting and will be locked again once it
    finishes waiting.</div>
<div class="start-param"><span class="tag-param">ms</span> - 
    The time-limit in milliseconds.  If this amount of time passes
    before the thread is woken up, then the thread will return as
    though it had been woken up.</div></div></div>
<p class="cdoc-item">
<a name="function_veThrCondSignal"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrCondSignal</span>
<div class="body-function">
<div class="codeblock">void veThrCondSignal(VeThrCond *c);</div>    <p>Signals that the event associated with a condition variable
    has occurred.  Wakes up one thread that is waiting on the
    condition variable.  That thread will then attempt to re-lock its
    mutex and return from its corresponding "wait" function call.
    If no threads are waiting on this condition variable, then this
    call has no effect.</p>
    
<div class="start-param"><span class="tag-param">c</span> - 
    The condition variable on which to wake up threads.</div></div></div>
<p class="cdoc-item">
<a name="function_veThrCondBcast"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrCondBcast</span>
<div class="body-function">
<div class="codeblock">void veThrCondBcast(VeThrCond *c);</div>    <p>Signals that the event associated with a condition variable
    has occurred.  Wakes up <i>all</i> threads that are waiting on the
    condition variable.
    If no threads are waiting on this condition variable, then this
    call has no effect.</p>
    
<div class="start-param"><span class="tag-param">c</span> - 
    The condition variable on which to wake up threads.</div></div></div>
<p class="cdoc-item">
<a name="function_veThrInitDelayGate"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrInitDelayGate</span>
<div class="body-function">
<div class="codeblock">void veThrInitDelayGate(void);</div>    <p>Initializes the delay gate.  Must be called before anything enters
    the delay gate.</div></div>
<p class="cdoc-item">
<a name="function_veThrDelayGate"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrDelayGate</span>
<div class="body-function">
<div class="codeblock">void veThrDelayGate(void);</div>    <p>Provided for threads that may be created during program initialization
    but which should not run until later.  Any such thread should call this
    function.  This function will not return until the 
    <code>veThrReleaseDelayed()</code> function is called from elsewhere in
    the program.</div></div>
<p class="cdoc-item">
<a name="function_veThrReleaseDelayed"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrReleaseDelayed</span>
<div class="body-function">
<div class="codeblock">void veThrReleaseDelayed(void);</div>    <p>Allows threads that are waiting in the delay gate to continue.
    After this function is called, the gate is considered open and any
    further threads that call <code>veThrDelayGate()</code> will not
    be stopped.</div></div>
<p class="cdoc-item">
<a name="function_veThreadInitDelayed"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThreadInitDelayed</span>
<div class="body-function">
<div class="codeblock">int veThreadInitDelayed(void *(*func)(void *), void *arg, 
			int priority, int flags);</div>    <p>This has the same effect as veThreadInit, except that actual
    instantiation of the thread will be delayed until the delay gate
    has been opened (by a call to <code>veThrReleaseDelayed()</code>).
    This allows threads to be setup but not actually created until needed.
    This approach helps on platforms with unusual thread characteristics 
    (e.g. Linux) and helps stability with multiple-process renderers.</p>
    <p>In general, all device drivers should use this interface instead
    of the <code>veThrDelayGate()</code> call.</p>
    <p>If the delay gate has already been released then this call has
    the identical effect as a call to <code>veThreadInit()</code>.
    For the details of the effects of the arguments, see 
    <code>veThreadInit()</code>.  Note that there is no argument that
    allows you to retrieve the id of a delayed thread.
    </p></div></div>
<p class="cdoc-item">
<a name="sect_0"></a><h2 class="tag-section">Thread-Specific Data</h2>
    The following functions provide abstractions for storing thread-specific
    data.
 
<p class="cdoc-item">
<a name="function_veThrKeyCreate"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrKeyCreate</span>
<div class="body-function">
<div class="codeblock">VeThrKey *veThrKeyCreate(VeThrDataFreeProc *);</div> </div></div>
<p class="cdoc-item">
<a name="function_veThrKeyDestroy"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrKeyDestroy</span>
<div class="body-function">
<div class="codeblock">void veThrKeyDestroy(VeThrKey *);</div> </div></div>
<p class="cdoc-item">
<a name="function_veThrDataGet"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrDataGet</span>
<div class="body-function">
<div class="codeblock">void *veThrDataGet(VeThrKey *);</div> </div></div>
<p class="cdoc-item">
<a name="function_veThrDataSet"></a><div class="start-function"><span class="label-function">Function:</span> <span class="tag-function">veThrDataSet</span>
<div class="body-function">
<div class="codeblock">void veThrDataSet(VeThrKey *, void *);</div> </div></div>

<h2 class="cdoc-index">Index</h2>
<ul>
<li><a class="link-function" href="#function_veThrBarrierCreate">veThrBarrierCreate (function)</a></li>
<li><a class="link-function" href="#function_veThrBarrierDestroy">veThrBarrierDestroy (function)</a></li>
<li><a class="link-function" href="#function_veThrBarrierEnter">veThrBarrierEnter (function)</a></li>
<li><a class="link-function" href="#function_veThrCondBcast">veThrCondBcast (function)</a></li>
<li><a class="link-function" href="#function_veThrCondCreate">veThrCondCreate (function)</a></li>
<li><a class="link-function" href="#function_veThrCondDestroy">veThrCondDestroy (function)</a></li>
<li><a class="link-function" href="#function_veThrCondSignal">veThrCondSignal (function)</a></li>
<li><a class="link-function" href="#function_veThrCondTimedWait">veThrCondTimedWait (function)</a></li>
<li><a class="link-function" href="#function_veThrCondWait">veThrCondWait (function)</a></li>
<li><a class="link-function" href="#function_veThrDataGet">veThrDataGet (function)</a></li>
<li><a class="link-function" href="#function_veThrDataSet">veThrDataSet (function)</a></li>
<li><a class="link-function" href="#function_veThrDelayGate">veThrDelayGate (function)</a></li>
<li><a class="link-function" href="#function_veThreadCreate">veThreadCreate (function)</a></li>
<li><a class="link-function" href="#function_veThreadDestroy">veThreadDestroy (function)</a></li>
<li><a class="link-function" href="#function_veThreadId">veThreadId (function)</a></li>
<li><a class="link-function" href="#function_veThreadInit">veThreadInit (function)</a></li>
<li><a class="link-function" href="#function_veThreadInitDelayed">veThreadInitDelayed (function)</a></li>
<li><a class="link-function" href="#function_veThreadKill">veThreadKill (function)</a></li>
<li><a class="link-function" href="#function_veThreadWait">veThreadWait (function)</a></li>
<li><a class="link-function" href="#function_veThrInitDelayGate">veThrInitDelayGate (function)</a></li>
<li><a class="link-function" href="#function_veThrKeyCreate">veThrKeyCreate (function)</a></li>
<li><a class="link-function" href="#function_veThrKeyDestroy">veThrKeyDestroy (function)</a></li>
<li><a class="link-function" href="#function_veThrMutexCreate">veThrMutexCreate (function)</a></li>
<li><a class="link-function" href="#function_veThrMutexDestroy">veThrMutexDestroy (function)</a></li>
<li><a class="link-function" href="#function_veThrMutexLock">veThrMutexLock (function)</a></li>
<li><a class="link-function" href="#function_veThrMutexUnlock">veThrMutexUnlock (function)</a></li>
<li><a class="link-function" href="#function_veThrReleaseDelayed">veThrReleaseDelayed (function)</a></li>
</ul>
</body>
</html>
