<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Standard BlueScript Reference</title>
    <link rel="stylesheet" type="text/css" href="bluescript.css">
  </head>

  <body>
    <h1>Standard BlueScript Reference</h1>

    <hr />
      <p><i><a href="index.hml">Return to index</a></i></p>
    
    <p>This document describes the set of procedures that are
      available in a <em>standard</em> BlueScript interpreter.
      Unless very specific control over procedures and functionality
      is required, it is expected that most BlueScript interpreters
      will contain the following functionality.</p>

    <ul>
	<li><a href="#Core">Core Procedures</a></li>
	<li><a href="#String">String Procedures</a></li>
	<li><a href="#List">List Procedures</a></li>
	<li><a href="#Hash">Hash Map Procedures</a></li>
	<li><a href="#Stream">Stream Procedures</a></li>
	<li><a href="#StreamOpt">Stream Procedures (Optional)</a></li>
    </ul>
    
    <a name="Core"></a>
    <h2>Core Procedures</h2>
    <p>These procedures provide the basic programming structure for
      BlueScript.</p> 
    
    <ul>
      <li><a href="#break">break</a></li>
      <li><a href="#catch">catch</a></li>
      <li><a href="#continue">continue</a></li>
      <li><a href="#cproc">cproc</a></li>
      <li><a href="#error">error</a></li>
      <li><a href="#expr">expr</a></li>
	<li><a href="#get">get</a></li>
      <li><a href="#foreach">foreach</a></li>
      <li><a href="#global">global</a></li>
      <li><a href="#if">if</a></li>
      <li><a href="#proc">proc</a></li>
      <li><a href="#return">return</a></li>
      <li><a href="#set">set</a></li>
      <li><a href="#try">try</a></li>
	<li><a href="#unset">unset</a></li>
      <li><a href="#while">while</a></li>
    </ul>

    <a name="break"></a>
    <div class="proc">
      <div class="procname">break</div>
      <div class="procsyn">
	<code>break</code>
      </div>
      <div class="procdesc">
	Halts processing of the current script block with a
	<code>BREAK</code> condition.  This condition is most
	commonly used by control procedures such as
	<code>while</code> and <code>foreach</code> to discontinue looping.
      </div>
    </div>

    <a name="catch"></a>
    <div class="proc">
      <div class="procname">catch</div>
      <div class="procsyn">
	<code>catch</code> <i>script</i> [<i>var</i>]
      </div>
      <div class="procdesc">
	<p>
	  Evaluates the given script trapping errors if they occur.
	  If an optional variable name is specified then the result of
	  evaluating the script is stored in the given variable,
	  regardless of whether the script generates a result or an
	  error.  In other words, if the script generates a result,
	  the result is stored in the given variable and if the script
	  generates an error, the error message is stored in the given
	  variable.  If no variable name is specified then the result
	  of evaluating the script is discarded.
	</p>
	<p>
	  This procedure returns the result code generated by
	  evaluting the script, as an integer.  
	  The following result codes are
	  defined:
	<dl>
	  <dt><b>0</b></dt>
	  <dd>OK - indicates that evaluation completed
	    successfully.</dd>
	  <dt><b>1</b></dt>
	  <dd>ERROR - indicates than an error was generated.</dd>
	  <dt><b>2</b></dt>
	  <dd>CONTINUE - indicates that an uncaught "continue" 
	    command was encountered.</dd>
	  <dt><b>3</b></dt>
	  <dd>BREAK - indicates that an uncaught "break" command
	    was encountered.</dd>
	  <dt><b>4</b></dt>
	  <dd>RETURN - indicates that a return command was
	    encoutnered.</dd> 
	</dl>
	Integers are used so that a Boolean test on the result can
	be performed to detect abnormal termination.  For example:
	<div class="eg">if [catch {cmd x y z}] { ... do something on error
	  ... }</div>
      </p>
      </div>
    </div>

    <a name="continue"></a>
    <div class="proc">
      <div class="procname">continue</div>
      <div class="procsyn">
	<code>continue</code>
      </div>
      <div class="procdesc">
	Halts processing of the current script block with a
	<code>CONTINUE</code> condition.  This condition is most
	commonly used by control procedures such as
	<code>while</code> and <code>foreach</code> to discontinue
	processing of the current iteration of a loop and continue
	on to the next iteration.
      </div>
    </div>

    <a name="cproc"></a>
    <div class="proc">
      <div class="procname">cproc</div>
      <div class="procsyn">
	<code>cproc</code> <i>name</i> <i>args</i> <i>script</i>
      </div>
      <div class="procdesc">
	<p>Creates a contextual procedure.  A contextual procedure is
	  like a global procedure except that it is only visible in the
	  current context as well as any nested context (e.g. the inside
	  of a foreach or while loop).  The procedure is removed when
	  the context is destroyed (e.g. the
	  function returns).</p>
	<p>See the <code>proc</code> command below for details on
	  arguments.</p>
      </div>
    </div>

    <a name="error"></a>
    <div class="proc">
      <div class="procname">error</div>
      <div class="procsyn">
	<code>error</code> [<i>name</i>]
      </div>
      <div class="procdesc">
	Generates an error.  This interrupts processing of the
	current script and will pop contexts off the stack until
	either the stack is exhausted (i.e. control is returned to
	the calling program indicating an error) or the error is
	caught (e.g. by the <code>catch</code> or <code>try</code>
	procedures).
      </div>
    </div>


    <a name="expr"></a>
    <div class="proc">
      <div class="procname">expr</div>
      <div class="procsyn">
	<code>expr</code> <i>e</i>
      </div>
      <div class="procdesc">
	The argument to this function must be an infix expression (as
	described in the main BlueScript documentation).  The function
	returns the result of evaluting the expression.  Any variable
	references or evaluation lists in the expression are evaluated
	in the same context in which the "expr" command is given.
      </div>
    </div>


    <a name="foreach"></a>
    <div class="proc">
      <div class="procname">foreach</div>
      <div class="procsyn">
	<code>foreach</code> <i>var</i> <i>list</i> <i>script</i>
      </div>
      <div class="procdesc">
	<p>
	  Evaluates the given <i>script</i> once for each element in
	  <i>list</i>.  This is done by setting the variable <i>var</i>
	  to each element in <i>list</i> in order, and evaluating
	  <i>script</i> for each one.  The <code>break</code> command
	  may be used in <i>script</i> to abort the loop, even if the
	  list has not yet been exhausted.  The <code>continue</code>
	  command may be used in <i>script</i> to abort the current
	  iteration of the loop, continuing with the next element in
	  <i>list</i> (if there are any left).
	</p>
	<p>
	  The list to iterate over (<i>list</i>) is read once at the
	  start of the loop and the loop works from a copy of
	  <i>list</i> after that.  Thus, the value contained in
	  <i>list</i> can be modified by the body of the loop without
	  disrupting the loop.
	</p>
	<p>
	  The result of this procedure is the result of the last
	  command executed in the script or a blank string if
	  nothing is evaluated.
	</p>
      </div>
    </div>

      <a name="get"></a>
      <div class="proc">
	<div class="procname">get</div>
	<div class="procsyn">
	  <code>get</code> <i>var</i>
	</div>
	<div class="procdesc">
	  Returns the value of the variable <i>var</i> if it exists,
	  or an empty string if the variable does not exist.
	</div>
      </div>

    <a name="global"></a>
    <div class="proc">
      <div class="procname">global</div>
      <div class="procsyn">
	<code>global</code> <i>var</i>
      </div>
      <div class="procdesc">
	<p>
	  Declares that variable <i>var</i> is global.  Any references
	  to the variable <i>var</i> after a <code>global</code>
	  command, within the same context or a nested context will
	  refer to the variable <i>var</i> in the global context
	  rather than the local context.  The variable <i>var</i> need
	  not already exist in the global context.  However if it does
	  not exist in the global context it will not be set to any
	  value until it is explicitly set (e.g. via the
	  <code>set</code> command).
	</p>
	<p>
	  Note that the use of <code>global</code> in the middle of a
	  script can have some unintended side effects.  For example,
	  if the following script is part of a procedure body:
	</p>
	<div class="eg">
	  set x 100<br />
	  global x<br />
	  set x 200
	</div>
	<p>
	  Then the first reference to <i>x</i> (before the call to
	  <code>global</code>) refers to <i>x</i> in the local
	  context.  The call to <code>global</code> actually destroys
	  the local variable <i>x</i> - the value is lost and cannot
	  be retrieved.  Also note that there is no way to undo the
	  effects of a <code>global</code> in the current context.
	  In this case, the reference to <i>x</i> will be to the
	  global <i>x</i> until the local context is destroyed.
	</p>
	<p>
	  Calling <code>global</code> while in the global context has
	  no effect.
	</p>
      </div>
    </div>

    <a name="if"></a>
    <div class="proc">
      <div class="procname">if</div>
      <div class="procsyn">
	<code>if</code> <i>expr</i> <i>true-script</i>
	[<code>else</code> <i>false-script</i>]
      </div>
      <div class="procdesc">
	<p>
	  Evaluates (or does not evaluate) blocks of code depending
	  upon the value of an expression.  The script
	  <i>true-script</i> is evaluated if and only if the infix
	  expression <i>expr</i> evaluates to a "true" Boolean value.
	  Optionally, a second script <i>false-script</i> may be
	  specified that will be evaluated in <i>expr</i> evaluates to
	  a "false" Boolean value.
	</p>
	<p>
	  The result of this procedure is the result of the last
	  command evaluated in whichever script body or an empty
	  string if nothing is evaluated.
	</p>
      </div>
    </div>

    <a name="proc"></a>
    <div class="proc">
      <div class="procname">proc</div>
      <div class="procsyn">
	<code>proc</code> <i>name</i> <i>args</i> <i>script</i>
      </div>
      <div class="procdesc">
	<p>
	  Creates a global procedure.  A global procedure is one that
	  can be accessed from any context.  Procedures use a
	  different namespace from variables.  Thus it is valid to
	  have a procedure and a variable with the same name.  These
	  two objects will be unrelated.
	</p>
	<p>
	  <i>args</i> specifies the number and names of arguments that
	  the procedure takes as a list.  For example an <i>args</i>
	  value of:
	</p>
	<div class="eg">
	  x y z
	</div>
	<p>
	  specifies that the procedure takes three arguments.  
	  When the procedure is called, then a new local context is
	  created and the three arguments will be stored in the local
	  variables <i>x</i>, <i>y</i>, <i>z</i> in the new context.
	</p>
	<p>
	  The argument list has two mechanisms for supporing variable
	  numbers of arguments.  The first is the specification of
	  <i>default values</i>.  For example, the specification of an
	  argument list as:
	</p>
	<div class="eg">
	  x y {z foo}
	</div>
	<p>
	  means that if the third argument (<i>z</i>) is not specified
	  in a call to the procedure, then it should take on the
	  default value "foo".  Default values can only be defined for
	  the right-most arguments.  For example, the following
	  definition is invalid:
	</p>
	<div class="eg">
	  x {y junk} z
	</div>
	<p>
	  However, more than one argument can be given a default value
	  so long as, for every argument with a default value, every
	  argument to its right must also have a default value.  For
	  example, the following:
	</p>
	<div class="eg">
	  {x foo} {y bar} {z glue}
	</div>
	<p>
	  is a valid way of specifying default values for all
	  arguments.
	</p>
	<p>
	  The second method is the <i>catch-all</i> argument.  If the
	  last argument name in the argument list is <i>args</i> then
	  any arguments passed to the procedure that are not consumed
	  by other arguments in the list are placed in a local
	  variable called <i>args</i>.  In other words, <i>args</i>
	  will contain a list of all arguments not handled by other
	  arguments (which will be empty if there are no extra
	  arguments).  For example, if a procedure has the following
	  argument list:
	</p>
	<div class="eg">
	  x y args
	</div>
	<p>
	  and the procedure is called with the following arguments:
	</p>
	<div class="eg">
	  a b c d e
	</div>
	<p>
	  The variable <i>x</i> would be set to "a", the variable
	  <i>y</i> would be set to "b" and the variable <i>args</i>
	  would be set to the list "c d e".
	</p>
	<p>
	  Default values and catch-all arguments can be combined, for
	  example: the following argument list is valid:
	</p>
	<div class="eg">
	  x {y foo} {z bar} args
	</div>
      </div>
    </div>

    <a name="return"></a>
    <div class="proc">
      <div class="procname">return</div>
      <div class="procsyn">
	<code>return</code> [<i>result</i>]
      </div>
      <div class="procdesc">
	Halts processing of the current script block with a
	<code>RETURN</code> condition.  This procedure may optionally
	set the result of the interpreter.  This condition is most
	commonly used to end a procedure call.
      </div>
    </div>

    <a name="set"></a>
    <div class="proc">
      <div class="procname">set</div>
      <div class="procsyn">
	<code>set</code> <i>var</i> [<i>value</i>]
      </div>
      <div class="procdesc">
	<p>
	  If both arguments are specified, then the variable <i>var</i>
	  is set to <i>value</i>.  If the variable <i>var</i> does not
	  yet exist, it is created first.  The procedure will return <i>value</i>.
	</p>
	<p>
	  If only one argument is specified, then the value of the
	  variable <i>var</i> is returned.  If the variable <i>var</i>
	  does not exist, then an error is generated.
	</p>
	<p>
	  Existence of a variable can be tested by trying to
	  <code>catch</code> a call to <code>set</code> with only one
	  argument.
	</p>
      </div>
    </div>

    <a name="try"></a>
    <div class="proc">
      <div class="procname">try</div>
      <div class="procsyn">
	<code>try</code> <i>script</i> <i>post</i>
      </div>
      <div class="procdesc">
	<p>
	  Evaluates <i>script</i> until it halts - whether from
	  reaching the end, encountering an exceptional condition
	  (<code>break</code>, <code>continue</code>,
	  <code>return</code>), or encountering an error.  The script
	  <i>post</i> will be executed regardless of how <i>script</i>
	  halts.  The idea is that <i>post</i> can be used to contain
	  "clean-up" code (e.g. closing an open file).  After
	  <i>post</i> is evaluated, the procedure returns as though
	  <i>post</i> had never been called - i.e. with whatever
	  condition came out of <i>script</i>.
	</p>
	<p>
	  Note that if an error is generated while processing
	  <i>post</i>, processing of <i>post</i> will halt and an
	  error will be generated.
	</p>
      </div>
    </div>

      <a name="unset"></a>
      <div class="proc">
	<div class="procname">unset</div>
	<div class="procsyn">
	  <code>unset</code> <i>var</i>
	</div>
	<div class="procdesc">
	  <p>
	    If the variable <i>var</i> is visible in the current
	    context, then it is destroyed.  After this has called, it
	    is as though the variable had never been set.  If the
	    variable <i>var</i> is not visible in the current context,
	    then this procedure has no effect.
	  </p>
	</div>
      </div>

    <a name="while"></a>
    <div class="proc">
      <div class="procname">while</div>
      <div class="procsyn">
	<code>while</code> <i>expr</i> <i>script</i>
      </div>
      <div class="procdesc">
	<p>Evaluates <i>script</i> so long as the expression
	  <i>expr</i> evaluates to a "true" Boolean value.  The
	  expression <i>expr</i> is evaluated before each evaluation of
	  <i>script</i>, including the first evaluation.  A
	  <code>break</code> command will cause the loop to terminate
	  without evaluating <i>expr</i>.  A <code>continue</code>
	  command will halt processing of the current iteration and
	  return to the top of the loop, checking <i>expr</i> first.
	</p>
	<p>
	  This procedure returns the result of the last command
	  evaluated in <i>script</i> or an empty string if nothing is
	  evaluated.
	</p>
      </div>
    </div>

    <a name="String"></a>
    <h2>String Procedures</h2>
    <p>These procedures provide basic string manipulation for
      BlueScript.</p>

    <ul>
      <li><a href="#append">append</a></li>
      <li><a href="#script">script</a></li>
      <li><a href="#split">split</a></li>
      <li><a href="#stris">stris</a></li>
      <li><a href="#strlen">strlen</a></li>
      <li><a href="#strstr">strstr</a></li>
      <li><a href="#substr">substr</a></li>
    </ul>

    <a name="append"></a>
    <div class="proc">
      <div class="procname">append</div>
      <div class="procsyn">
	<code>append</code> <i>var</i> <i>string</i>
      </div>
      <div class="procdesc">
	<p>
	  Appends the given <i>string</i> to the string stored in the
	  variable <i>var</i>.  The variable <i>var</i> must already
	  exist - otherwise, an error will be generated.
	</p>
	<p>
	  This procedure returns the value of <i>var</i> after
	  appending the string.
	</p>
      </div>
    </div>

    <a name="script"></a>
    <div class="proc">
      <div class="procname">script</div>
      <div class="procsyn">
	  <code>script</code> <i>string</i>
      </div>
      <div class="procdesc">
	  Splits the given <i>string</i> into a sequence of commands
	  in the same manner as a normal script.  That is:
	  <ul>
	    <li>Blank lines are ignored</li>
	    <li>Lines beginning with '#' are treated as comments and
	      ignored</li>
	    <li>All other lines are treated as commands.  Commands
	      that cross multiple lines (by escaping or quoting the
	      newline character) are treated properly (i.e. each
	      command ultimately equates to a single element in the
	      resulting list).</li>
	  </ul>
      </div>
    </div>

    <a name="split"></a>
    <div class="proc">
      <div class="procname">split</div>
      <div class="procsyn">
	<code>split</code> <i>string</i> [<i>chars</i>]
      </div>
      <div class="procdesc">
	  <p>
	    Generates a list by splitting <i>string</i> into fragments
	    using <i>chars</i> as delimiters.  If <i>chars</i> is not
	    specified as an argument then the set of whitespace characters
	    (' ', '\r', '\n', '\t', '\v') is used.
	  </p>
	  <p>
	    If <i>chars</i> is specified as an empty string or list,
	    e.g.
	    <div class="eg">
	      split "Hello World!" {}
	    </div>
	    then the input string is split into a list of the
	    individual characters that make up the string, e.g.:
	    <div class="eg">
	      H e l l o { } W o r l d !
	    </div>
	  </p>
	  <p>
	    Although a string can normally be considered as a list
	    without any conversion, the <code>split</code> command has
	    a number of subtle differences:
	    <ul>
	      <li>Normally if a string is interpreted as a list, 
		extra whitespace between two subsequent elements of a
		list are ignored.  With the split command, extra
		whitespace elements are not ignored.  For example, the
		following:
		<div class="eg">
		  split {a b &nbsp;c}
		</div>
		would return the list:
		<div class="eg">
		  a b {} c
		</div>
	      </li>
	      <li>
		A string can be directly interpreted as a list only
		if its quoting is syntactically correct (e.g. all '{'
		characters are balanced by a '}' character).  The
		<code>split</code> command has no such restriction and
		treats all special characters (including quoting
		characters) as though they were ordinary characters.
	      </li>
	  </p>
      </div>
    </div>

    <a name="stris"></a>
    <div class="proc">
      <div class="procname">stris</div>
      <div class="procsyn">
	  <code>stris</code> <i>type</i> <i>string</i>
      </div>
      <div class="procdesc">
	  <p>
	    Returns true ('1') if the given <i>string</i> matches the
	    given <i>type</i> or false ('0') if it does not match the
	    type.  The following types are defined:
	  </p>
	  <dl>
	    <dt><code>integer</code></dt>
	    <dd>
	      Any valid BlueScript integer representation.
	      Leading white-space is ignored but trailing white-space
	      is not.
	      If this type matches, then it is safe to interpret this
	      string as an integer.
	    </dd>
	    <dt><code>float</code></dt>
	    <dd>
	      Any valid BlueScript floating-point representation.
	      Leading white-space is ignored but trailing white-space
	      is not.
	      If this type matches, then it is safe to interpret this
	      string as a floating-point number.
	    </dd>
	    <dt><code>number</code></dt>
	    <dd>
	      Any valid numerical representation - integer or
	      floating-point.
	    </dd>
	    <dt><code>blank</code></dt>
	    <dd>
	      Any string comprised solely of whitespace (' ', '\r',
	      '\n', '\t', '\v') characters.
	    </dd>
	  </dl>
      </div>
    </div>

    <a name="strlen"></a>
    <div class="proc">
      <div class="procname">strlen</div>
      <div class="procsyn">
	<code>strlen</code> <i>string</i>
      </div>
      <div class="procdesc">
	Returns the length of <i>string</i> in characters.
      </div>
    </div>

    <a name="strstr"></a>
    <div class="proc">
      <div class="procname">strstr</div>
      <div class="procsyn">
	  <code>strstr</code> <i>string</i> <i>substring</i>
      </div>
      <div class="procdesc">
	  Returns the offset of the first occurrence of
	  <i>substring</i>
	  in <i>string</i> as an integer.  For example, an offset of 0
	  indicates that the first occurrence of <i>substring</i> is
	  at the start of <i>string</i>.
	  If <i>substring</i> is not found, then -1 is returned.
      </div>
    </div>

    <a name="substr"></a>
    <div class="proc">
      <div class="procname">substr</div>
      <div class="procsyn">
	<code>substr</code> <i>string</i> <i>start</i> [<i>length</i>]
      </div>
      <div class="procdesc">
	Returns a fragment of <i>string</i> from the position
	<i>start</i> of up to <i>length</i> characters.  The returned string
	will be shorter than <i>length</i> if <i>string</i> has less
	than <i>length</i>-<i>start</i> characters.  The position
	<i>start</i> is measured in characters, with "0" corresponding
	to the first character inthe string.  If <i>length</i> is not
	specified, then all characters from <i>start</i> to the end of
	the string are returned.
      </div>
    </div>

      <a name="List"></a>
      <h2>List Procedures</h2>
      <p>These procedures provide basic list manipulation for
	BlueScript.</p>
      <p>Many of the procedures below refer to an element of the list
	by an <i>index</i>.  An index indicates a position in the
	list.  It can have one of the following forms:
	<ul>
	  <li><i>i</i> where <i>i</i> is an integer.  The value 0
	    refers to the first element in the list, the value 1 to
	    the second and so on.</li>
	  <li><code>end</code> which refers to the last element in the
	    list.</li>
	  <li><code>end-</code><i>i</i> which refers to the
	    <i>i</i>'th element before the end.  For example
	    <code>end-0</code> refers to the last element,
	    <code>end-1</code> refers to the next-to-last element,
	    <code>end-2</code> refers to the next-to-next-to-last
	    element and so on.
	  </li>
	</ul>
      </p>
      
      <ul>
	<li><a href="#lconcat">lconcat</a></li>
	<li><a href="#lempty">lempty</a></li>
	<li><a href="#lindex">lindex</a></li>
        <li><a href="#list">list</a></li>
	<li><a href="#llength">llength</a></li>
	<li><a href="#lpop">lpop</a></li>
	<li><a href="#lpush">lpush</a></li>
	<li><a href="#lrange">lrange</a></li>
	<li><a href="#lreplace">lreplace</a></li>
	<li><a href="#lshift">lshift</a></li>
	<li><a href="#lunshift">lunshift</a></li>
      </ul>
     
      <a name="lconcat"></a>
      <div class="proc">
	<div class="procname">lconcat</div>
	<div class="procsyn">
	  <code>lconcat</code> [<i>list</i> ...]
	</div>
	<div class="procdesc">
	  Returns the result of concatenating all arguments (each one
	  treated as a list) together.  For example:
	  <div class="eg">
	    lconcat {a b c} {d e} f {g h i}
	  </div>
	  would return:
	  <div class="eg">
	    a b c d e f g h i
	  </div>
	  If no arguments are specified then the result is an empty list.
	  This procedure will generate an error if
	  any of the <i>list</i> arguments is not a valid list.	
	</div>
      </div>

      <a name="lempty"></a>
      <div class="proc">
	<div class="procname">lempty</div>
	<div class="procsyn">
	  <code>lempty</code> <i>list</i>
	</div>
	<div class="procdesc">
	  Returns true ('1') if <i>list</i> is an empty list or false
	  ('0') otherwise.  This procedure will generate an error if
	  <i>list</i> is not a valid list.
	</div>
      </div>

      <a name="lindex"></a>
      <div class="proc">
	<div class="procname">lindex</div>
	<div class="procsyn">
	  <code>lindex</code> <i>list</i> <i>index</i>
	</div>
	<div class="procdesc">
	  <p>
	    Returns the element of <i>list</i> at <i>index</i>.  See the
	    discussion at the beginning of this section for a
	    description on the valid forms of an index.
	    This procedure will generate an error if
	    <i>list</i> is not a valid list.
	  </p>
	  <p>
	    If <i>index</i> points to an element that is outside of
	    the list (i.e. before the beginning or after the end) then
	    an empty string is returned.
	  </p>
	</div>
      </div>

      <a name="list"></a>
      <div class="proc">
	<div class="procname">list</div>
	<div class="procsyn">
	  <code>list</code> [<i>elem</i> ...]
	</div>
	<div class="procdesc">
	  <p>
	  Returns a list containing its arguments.  This function
	  is provided as an alternate form of list construction that
	  does not require any syntactic parsing. 
	  </p>
        </div>
      </div>

      <a name="llength">
      <div class="proc">
	<div class="procname">llength</div>
	<div class="procsyn">
	  <code>llength</code> <i>list</i>
	</div>
	<div class="procdesc">
	  Returns the length of <i>list</i> in elements.
	  This procedure will generate an error if
	  <i>list</i> is not a valid list.
	</div>
      </div>

      <a name="lpop">
      <div class="proc">
	<div class="procname">lpop</div>
	<div class="procsyn">
	  <code>lpop</code> <i>listvar</i>
	</div>
	<div class="procdesc">
	  Removes the last element of the list contained in the
	  variable <i>listvar</i> if there is one and
	  returns it. If <i>listvar</i> contains an empty list, then
	  an empty string is returned.
	  This procedure will generate an error if
	  <i>listvar</i> does not contain a valid list or if the
	  variable does not exist.
	  <p>Note that this procedure <em>modifies</em> the contents
	    of <i>listvar</i>.  For example, given the script:
	    <div class="eg">
	      set x {a b c}
	      set y [lpop x]
	    </div>
	    After evaluation, <i>y</i> will be "c" and <i>x</i> will
	    be "a b".  Also note that in this case we refer to the
	    variable <i>x</i> by name only since we want to modify the
	    contents of variable rather than simply retrieving its value.
	  </p>
	</div>
      </div>

      <a name="lpush">
      <div class="proc">
	<div class="procname">lpush</div>
	<div class="procsyn">
	  <code>lpush</code> <i>listvar</i> <i>value</i>
	</div>
	<div class="procdesc">
	  Adds <i>value</i> to the end of the list contained in the
	  variable <i>listvar</i>.  The variable <i>listvar</i> must
	  exist and be accessible in the current context and must
	  contain a valid (but possibly empty) list.
	  <p>Note that this procedure <em>modifies</em> the contents
	    of <i>listvar</i>.  For example, given the script:
	    <div class="eg">
	      set x {a b c}
	      lpush x d
	    </div>
	    After evaluation, <i>x</i> will be "a b c d".
	    Also note that in this case we refer to the
	    variable <i>x</i> by name only since we want to modify the
	    contents of variable rather than simply retrieving its value.
	  </p>
	</div>
      </div>

      <a name="lrange">
      <div class="proc">
	<div class="procname">lrange</div>
	<div class="procsyn">
	  <code>lrange</code> <i>list</i> <i>start</i> <i>end</i>
	</div>
	<div class="procdesc">
	  Returns a fragment of <i>list</i> containing all elements
	  from index <i>start</i> to index <i>end</i> inclusive.  If
	  this range extends outside the bounds of the list, then the
	  range will be truncated to only include those elements that
	  are actually part of the list.  This procedure will generate
	  an error if <i>list</i> is not a valid list.
	</div>
      </div>

      <a name="lreplace">
      <div class="proc">
	<div class="procname">lreplace</div>
	<div class="procsyn">
	  <code>lreplace</code> <i>list</i> <i>start</i> <i>end</i>
	  [<i>elem</i> ...]
	</div>
	<div class="procdesc">
	  Returns <i>list</i>, but with all elements in the range of
	  index <i>start</i> to index <i>end</i> (inclusive) replaced
	  with all arguments after <i>end</i> (i.e. <i>elem</i> ...).
	  For example:
	  <div class="eg">
	    lreplace {a b c d e} 1 2 {x y z}
	  </div>
	  would return:
	  <div class="eg">
	    a x y z d e
	  </div>
	  If no elements are specified on the command-line, then the
	  effect is to return <i>list</i> with the given range of
	  elements deleted (in effect, the negated effect of
	  <code>lrange</code>).  For example:
	  <div class="eg">
	    lreplace {a b c d e} 1 2
	  </div>
	  would return:
	  <div class="eg">
	    a d e
	  </div>
	</div>
      </div>

      <a name="lshift">
      <div class="proc">
	<div class="procname">lshift</div>
	<div class="procsyn">
	  <code>lshift</code> <i>listvar</i>
	</div>
	<div class="procdesc">
	  Removes the first element of the list contained in the
	  variable <i>listvar</i> if there is one and
	  returns it. If <i>listvar</i> contains an empty list, then
	  an empty string is returned.
	  This procedure will generate an error if
	  <i>list</i> is not a valid list.
	  <p>Note that this procedure <em>modifies</em> the contents
	    of <i>list</i>.  For example, given the script:
	    <div class="eg">
	      set x {a b c}
	      set y [lshift x]
	    </div>
	    After evaluation, <i>y</i> will be "a" and <i>x</i> will
	    be "b c".  Also note that in this case we refer to the
	    variable <i>x</i> by name only since we want to modify the
	    contents of variable rather than simply retrieving its value.
	  </p>
	</div>
      </div>
      
      <a name="lunshift">
      <div class="proc">
	<div class="procname">lunshift</div>
	<div class="procsyn">
	  <code>lunshift</code> <i>listvar</i> <i>value</i>
	</div>
	<div class="procdesc">
	  Adds <i>value</i> to the beginning of the list contained in the
	  variable <i>listvar</i>.  The variable <i>listvar</i> must
	  exist and be accessible in the current context and must
	  contain a valid (but possibly empty) list.
	  <p>Note that this procedure <em>modifies</em> the contents
	    of <i>listvar</i>.  For example, given the script:
	    <div class="eg">
	      set x {a b c}
	      lunshift x d
	    </div>
	    After evaluation, <i>x</i> will be "d a b c".
	    Also note that in this case we refer to the
	    variable <i>x</i> by name only since we want to modify the
	    contents of variable rather than simply retrieving its value.
	  </p>
	</div>
      </div>

      <a name="Hash"></a>
      <h2>Hash Map Procedures</h2>

      <p>Hash maps are associative arrays that map one value (a
	<i>key</i>) onto
	another (a <i>value</i>).  
	Hash maps are implemented as opaque objects.  This
	means that once a map is created it is passed around as a
	reference.</p>
      
      <ul>
	<li><a href="#hash">hash</a></li>
	<li><a href="#h_clear"><i>hash</i> clear</a></li>
	<li><a href="#h_copy"><i>hash</i> copy</a></li>
	<li><a href="#h_export"><i>hash</i> export</a></li>
	<li><a href="#h_get"><i>hash</i> get</a></li>
	<li><a href="#h_has"><i>hash</i> has</a></li>
	<li><a href="#h_import"><i>hash</i> import</a></li>
	<li><a href="#h_keys"><i>hash</i> keys</a></li>
	<li><a href="#h_set"><i>hash</i> set</a></li>
	<li><a href="#h_unset"><i>hash</i> unset</a></li>
	<li><a href="#h_values"><i>hash</i> values</a></li>
      </ul>

      <a name="hash"></a>
      <div class="proc">
	<div class="procname">hash</div>
	<div class="procsyn">
	  <code>hash</code>
	</div>
	<div class="procdesc">
	  Creates a new empty opaque "hash" object.  Member functions
	  for the returned object are described below.
	</div>
      </div>

      <a name="h_clear"></a>
      <div class="proc">
	<div class="procname"><i>hash</i> clear</div>
	<div class="procsyn">
	  <i>hash</i> <code>clear</code>
	</div>
	<div class="procdesc">
	  Empties the hash object, so that there are no keys or values
	  left in it.
	</div>
      </div>
      
      <a name="h_copy"></a>
      <div class="proc">
	<div class="procname"><i>hash</i> copy</div>
	<div class="procsyn">
	  <i>hash</i> <code>copy</code>
	  </div>
	<div class="procdesc">
	  Returns a reference to a new "hash" object which contains
	  the same keys and values of the current one.  Note that the
	  returned object is a copy, not a reference to the original,
	  so one may be modified without disrupting the other.
	</div>
      </div>

      <a name="h_export"></a>
      <div class="proc">
	<div class="procname"><i>hash</i> export</div>
	<div class="procsyn">
	  <i>hash</i> <code>export</code>
	</div>
	<div class="procdesc">
	  Converts the contents of the hash into a list.  Each element
	  of the list is itself a list of two elements: a <i>key</i>
	  and its corresponding <i>value</i>.  This may be used in
	  combination with the <code>import</code> command to save and
	  restore the contents of a hash map.
	</div>
      </div>

      <a name="h_get"></a>
      <div class="proc">
	<div class="procname"><i>hash</i> get</div>
	<div class="procsyn">
	  <i>hash</i> <code>get</code> <i>name</i>
	</div>
	<div class="procdesc">
	  An analogue to the standard <code>get</code> command.
	  Returns the value corresponding to the key <i>name</i> if it
	  exists.  If it does not exist, then an empty string is returned.
	</div>
      </div>

      <a name="h_has"></a>
      <div class="proc">
	<div class="procname"><i>hash</i> has</div>
	<div class="procsyn">
	  <i>hash</i> <code>has</code> <i>key</i>
	</div>
	<div class="procdesc">
	  Returns true ('1') if the given <i>key</i> exists in the
	  map.  Otherwise it returns false ('0').
	</div>
      </div>

      <a name="h_import"></a>
      <div class="proc">
	<div class="procname"><i>hash</i> import</div>
	<div class="procsyn">
	  <i>hash</i> <code>import</code> <i>list</i>
	</div>
	<div class="procdesc">
	  <p>
	    Imports the given hash map contents (represented as a list)
	    into the current map.  The format of <i>list</i> is the same
	    as that of the output of the <code>export</code> command.
	    The list is mode of elements that are in turn lists of two
	    elements: a <i>key</i> and a <i>value</i>.
	  </p>
	  <p>
	    This operation updates the existing map.  If there are
	    keys in the existing map with that are the same as a key
	    in the import list, then those keys will be overwritten.
	    If there are keys in the existing map that do not have a
	    corresponding value in the import list, then those keys
	    will not be modified.
	  </p>
	</div>
      </div>

      <a name="h_keys"></a>
      <div class="proc">
	<div class="procname"><i>hash</i> keys</div>
	<div class="procsyn">
	  <i>hash</i> <code>keys</code>
	</div>
	<div class="procdesc">
	  Returns a list of all keys in the map.  If the map is empty,
	  then an empty list is returned.
	</div>
      </div>

      <a name="h_set"></a>
      <div class="proc">
	<div class="procname"><i>hash</i> set <i>key</i>
	  [<i>value</i>]</div>
	<div class="procsyn">
	  <p>
	    An analogue to the standard <code>set</code> command.
	    If both arguments are specified, then <i>key</i> will be
	    mapped to <i>value</i> in the map.  If only <i>key</i> is
	    specified, then the value that is mapped to <i>key</i> in
	    the map will be returned, or, if <i>key</i> is not in the
	    map, an error will be generated.
	  </p>
	</div>
      </div>

      <a name="h_unset"></a>
      <div class="proc">
	<div class="procname"><i>hash</i> unset <i>key</i></div>
	<div class="procsyn">
	  <p>
	    An analogue to the standard <code>unset</code> command.
	    Removes <i>key</i> from the map, if it exists.  If it does
	    not exist in the map, then this command has no effect and
	    no error is generated.
	  </p>
	</div>
      </div>

      <a name="h_values"></a>
      <div class="proc">
	<div class="procname"><i>hash</i> values</div>
	<div class="procsyn">
	  <i>hash</i> <code>values</code>
	</div>
	<div class="procdesc">
	  Returns a list of all values in the map.  If the map is empty,
	  then an empty list is returned.
	</div>
      </div>

      <a name="Stream"></a>
      <h2>Stream Procedures</h2>
      <p>
	Streams (sequences of bytes that can be read and-or written)
	are not returned by any function in Standard BlueScript.
	[Note:  There are optional functions that do so - see below.]
	However, other modules may make use of stream objects, so the
	common methods for stream objects are denoted below.
      </p>
      <ul>
	<li><a href="#s_close"><i>stream</i> close</a></li>
	<li><a href="#s_flush"><i>stream</i> flush</a></li>
	<li><a href="#s_getc"><i>stream</i> getc</a></li>
	<li><a href="#s_poll"><i>stream</i> poll</a></li>
	<li><a href="#s_read"><i>stream</i> read</a></li>
	<li><a href="#s_readblock"><i>stream</i> readblock</a></li>
	<li><a href="#s_readln"><i>stream</i> readln</a></li>
	<li><a href="#s_write"><i>stream</i> write</a></li>
	<li><a href="#s_writeln"><i>stream</i> writeln</a></li>
      </ul>
    
      <a name="s_close"></a>
      <div class="proc">
	<div class="procname"><i>stream</i> close</div>
	<div class="procsyn">
	  <i>stream</i> <code>close</code>
	</div>
	<div class="procdesc">
	  Explicitly closes the stream.  Nothing further may be
	  written to or read from the stream.  Any buffers are flushed
	  and the underlying stream implementation is notified of the
	  closing.  For example, if <i>stream</i> represents a network
	  socket, the network socket will be shutdown.
	</div>
      </div>
	
      <a name="s_flush"></a>
      <div class="proc">
	<div class="procname"><i>stream</i> flush</div>
	<div class="procsyn">
	  <i>stream</i> <code>flush</code>
	</div>
	<div class="procdesc">
	  Forces the stream to flush any output buffers, whether in
	  the stream object itself or its underlying implementation.
	</div>
      </div>

      <a name="s_getc"></a>
      <div class="proc">
	<div class="procname"><i>stream</i> getc</div>
	<div class="procsyn">
	  <i>stream</i> <code>getc</code>
	</div>
	<div class="procdesc">
	  Reads the next character from the stream and returns it.
	  If there are no characters left in the stream, then an empty
	  string is returned.
	</div>
      </div>

      <a name="s_poll"></a>
      <div class="proc">
	<div class="procname"><i>stream</i> poll</div>
	<div class="procsyn">
	  <i>stream</i> <code>poll</code> (<code>read</code>|<code>write</code>)
	</div>
	<div class="procdesc">
	  Checks the given stream to see if there is either data
	  available to be read (<code>read</code>) or if data can be
	  written without blocking (<code>write</code>).  Returns a
	  corresponding Boolean value ('1' or '0').  If the underlying
	  implementation does not support polling, an error is generated.
	</div>
      </div>

      <a name="s_read"></a>
      <div class="proc">
	<div class="procname"><i>stream</i> read</div>
	<div class="procsyn">
	  <i>stream</i> <code>read</code> [<i>n</i>]
	</div>
	<div class="procdesc">
	  <p>
	    Reads data from the stream.  If <i>n</i> is omitted, then
	    this function will read all available data up to an
	    "end-of-file" condition.  If <i>n</i> is specified, then any
	    available data up to <i>n</i> bytes are read.  The read data
	    is returned as a string.
	  </p>
	  <p>
	    Note that given a size to read <i>n</i>, it is valid
	    for this function to return a string that has fewer than
	    <i>n</i> bytes yet not be at the "end-of-file".
	    See <code>readblock</code> below for a method by which to
	    read a precise number of bytes.
	  </p>
	</div>
      </div>

      <a name="s_readblock"></a>
      <div class="proc">
	<div class="procname"><i>stream</i> readblock</div>
	<div class="procsyn">
	  <i>stream</i> <code>readblock</code> <i>n</i> [<i>var</i>]
	</div>
	<div class="procdesc">
	  <p>
	    <p>
	      Reads exactly <i>n</i> bytes from the stream.  
	      If the stream is currently in an "end-of-file" condition,
	      then an empty string is returned (regardless of whether or
	      not <i>var</i> is specified).
	      Otherwise, if <i>n</i> bytes cannot be read, then an error
	      is generated.
	    </p>
	    <p>
	      If <i>var</i> is not specified, then the read data is
	      returned or a blank string is returned if an
	      "end-of-file" was encountered.  If <i>var</i> is specified, then the read
	      data is stored in the variable <i>var</i> in the current
	      context and returns a Boolean value indicating whether
	      or not a block was read ('1' if a block was stored in
	      <i>var</i> or '0' if an "end-of-file" was encountered at
	      the beginning of the block).
	    </p>
	    <p>
	      Note that an "end-of-file" is only recognized as such if
	      it occurs before any characters are actually read.  If
	      an "end-of-file" is encountered in the middle of a block
	      it is treated as a "short block" error.
	    </p>
	</div>
      </div>

      <a name="s_readln"></a>
      <div class="proc">
	<div class="procname"><i>stream</i> readln</div>
	<div class="procsyn">
	  <i>stream</i> <code>readln</code> [<i>var</i>]
	</div>
	<div class="procdesc">
	  Reads the next line from the given stream.  If <i>var</i> is
	  not specified then the line that was read is returned, or an
	  error is generated if an "end-of-file" is encountered.
	  If <i>var</i> is specified then the line is
	  stored in the variable <i>var</i> in the current context and
	  a Boolean value is returned to indicate whether or not a
	  line was read ('1' indicates a line was read and stored in
	  <i>var</i> and '0' indicates that an "end-of-file" was
	  encountered).
	</div>
      </div>

      <a name="s_write"></a>
      <div class="proc">
	<div class="procname"><i>stream</i> write</div>
	<div class="procsyn">
	  <i>stream</i> <code>write</code> <i>string</i>
	</div>
	<div class="procdesc">
	  Writes the given <i>string</i> to the stream.
	  Returns <i>string</i>.
	</div>
      </div>

      <a name="s_writeln"></a>
      <div class="proc">
	<div class="procname"><i>stream</i> write</div>
	<div class="procsyn">
	  <i>stream</i> <code>writeln</code> <i>string</i>
	</div>
	<div class="procdesc">
	  Writes the given <i>string</i> to the stream followed
	  by a newline character.  Returns <i>string</i>.
	</div>
      </div>
      
      <a name="StreamOpt"></a></li>
      <h2>Stream Procedures (Optional)</h2>
      <p>These procedures are <em>not</em> available by default in a
	Standard BlueScript interpreter.  However, they may be enabled
	on some implementations (e.g. the <code>bssh</code>
	program).</p>

      <ul>
	<li><a href="#fopen">fopen</a></li>
	<li><a href="#stderr">stderr</a></li>
	<li><a href="#stdin">stdin</a></li>
	<li><a href="#stdio">stdio</a></li>
	<li><a href="#stdout">stdout</a></li>
      </ul>

      <a name="fopen"></a>
      <div class="proc">
	<div class="procname">fopen</div>
	<div class="procsyn">
	  <code>fopen</code> <i>filename</i> [<i>mode</i>]
	</div>
	<div class="procdesc">
	  Opens a file as a stream object.  The file to open is
	  specified by <i>filename</i>.  The mode in which to open the
	  file is specified by <i>mode</i> which corresponds to the
	  Standard C modes for the fopen() call:
	  <dl>
	    <dt><code>r</code></dt>
	    <dd>Open file for reading at the beginning of the file.</dd>
	    <dt><code>r+</code></dt>
	    <dd>Open file for reading and writing at the beginning of
	      the file.</dd>
	    <dt><code>w</code></dt>
	    <dd>Truncate file and open for writing at the beginning of
	      the file.</dd>
	    <dt><code>w+</code></dt>
	    <dd>Truncate file and open for reading and writing at the
	      beginning of the file.</dd>
	    <dt><code>a</code></dt>
	    <dd>Open for writing at the end of the file.</dd>
	    <dt><code>a+</code></dt>
	    <dd>Open for reading and writing at the end of the
	      file</dd>
	  </dl>
	  All writing modes will create the file if it does not exist.
	  <p>Returns a newly created stream object on success.
	    Otherwise, an error is generated.</p>
	</div>
      </div>

      <a name="stderr"></a>
      <div class="proc">
	<div class="procname">stderr</div>
	<div class="procsyn">
	  <code>stderr</code>
	</div>
	<div class="procdesc">
	  Returns a stream object that points to the write-only
	  <code>stderr</code> channel.
	</div>
      </div>

      <a name="stdin"></a>
      <div class="proc">
	<div class="procname">stdin</div>
	<div class="procsyn">
	  <code>stdin</code>
	</div>
	<div class="procdesc">
	  Returns a stream object that points to the read-only
	  <code>stdin</code> channel.
	</div>
      </div>

      <a name="stdio"></a>
      <div class="proc">
	<div class="procname">stdio</div>
	<div class="procsyn">
	  <code>stdio</code>
	</div>
	<div class="procdesc">
	  Returns a stream object that combines <code>stdin</code> and
	  <code>stdout</code>.  Writes to the stream will be send to
	  <code>stdout</code> and reads from the stream will come from
	  <code>stdin</code>.
	</div>
      </div>

      <a name="stdout"></a>
      <div class="proc">
	<div class="procname">stdout</div>
	<div class="procsyn">
	  <code>stdout</code>
	</div>
	<div class="procdesc">
	  Returns a stream object that points to the write-only
	  <code>stdout</code> channel.
	</div>
      </div>
      
  </body>
</html>
