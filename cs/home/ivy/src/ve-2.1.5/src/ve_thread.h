#ifndef VE_THREAD_H
#define VE_THREAD_H

/* system-specific thread definitions are located in another header */
/* Defines: VeThread, VeThrMutex, VeThrCond, VeThrBarrier */
#include <ve_thread_sys.h>

#ifdef __cplusplus
extern "C" {
#endif
#if 0
} /* yes this does nothing, but it fools the indentation in emacs */
#endif

/** misc
    <p>The ve_thread module provides an abstract interface for working
    with threads.  Much of this is targetted towards the library itself
    but can also be used by applications based upon the library.</p>
    <p>Most of the types used in this module should be considered
    opaque and should only be generated by calls to the library.
    The <i>ve_thread_sys</i> module has more on the cross-platform nature
    of the thread support.</p>
    <p>Since this module is meant as support to the rest of the library,
    any reference to the "application" in the documentation can be taken
    to mean any code, program, or library which calls this module.  The
    "current thread" refers to the thread that calls the given function.</p>
*/

/** function veThrBarrierCreate
    Creates a barrier.  A barrier will stop all threads as they enter the 
    barrier and will only let them go once a particular number of threads
    have arrived.
    
    @param size
    The number of threads that must arrive in the barrier before the
    threads are released.  This number is fixed for a given barrier -
    it cannot be changed once the barrier is created.

    @returns
    A pointer to a newly allocated barrier.  This barrier must be
    destroyed with <code>veThrBarrierDestroy()</code> in order to free
    the memory associated with the barrier.
 */
VeThrBarrier *veThrBarrierCreate(int size);

/** function veThrBarrierDestroy
    Destroys a barrier and deallocates its associated resources.  It is up
    to the application to ensure that there are no threads in the barrier
    when it is destroyed.
    
    @param b
    A pointer to the barrier to be destroyed.  This barrier must have
    been generated by a call to <code>veThrBarrierCreate()</code>.
*/
void veThrBarrierDestroy(VeThrBarrier *b);

/** function veThrBarrierEnter
    Causes the current thread to enter the specified barrier.  Once the
    thread enters the barrier it will block until the barrier has filled
    with threads (determined by the barrier's size).  Once the barrier
    has filled, all threads in the barrier will be released.  This
    function does not return until the threads are released.

    @param b
    A pointer to the barrier to enter.  This barrier must have been
    generated by a call to <code>veThrBarrierCreate()</code>.
*/
void veThrBarrierEnter(VeThrBarrier *b);

/** function veThreadCreate
    Creates a new thread object.  Note that the thread is not active
    until it has been initialized by a call to <code>veThreadInit</code>.
    
    @returns
    A pointer to the newly created thread object.  This object must be
    disposed of by calling <code>veThreadDestroy</code> to release its
    associated resources.
*/
VeThread *veThreadCreate(); /* creates an uninit thread structure */

/** function veThreadId
    Attempts to determine a unique identifier for the current thread.
    This should only be used for debugging reporting - it may not
    work properly on all platforms.

    @returns
    An integer identifying the current thread,if possible.
*/
int veThreadId(void);

/* thread creation flags...there's only one for now */
#define VE_THR_KERNEL (1<<0)

/** function veThreadInit
    <p>Initializes a thread.  After this call, the thread will begin to
    execute code starting at the specified function.  A priority may
    be specified - higher values indicate threads that run at a higher
    priority.</p>

    @param t
    A pointer to the thread object to initialize.  If this value is 
    <code>NULL</code> then an anonymous thread will be created.  That is,
    the thread will exist and run, but there will be no <code>VeThread</code>
    structure attached to it.  Such a thread cannot be controlled via the 
    <code>VeThreadKill()</code> and <code>VeThreadWait()</code> calls.

    @param func
    The function at which the thread will start execution.  Upon returning
    from this function, the thread will stop execution.  This function should
    take a single <code>void *</code> argument.

    @param arg
    The argument which will be passed to the function <code>func</code>.
    
    @param priority
    A non-negative priority to assign this thread.  Higher values indicate
    a higher priority.  If the specified priority exceeds system values,
    then the value will be clamped.  An implementation may choose to ignore
    specified thread priorities and run all threads at the same priority.
    Hence, this argument is purely advisory.

    @param flags
    The bitwise-or of a number of possible option flags.  Currently, only
    the <code>VE_THR_KERNEL</code> flag is defined.  By default, the 
    thread system will
    tend towards creating user-level threads.  If <code>VE_THR_KERNEL</code> 
    is specified then the system will attempt to create a kernel-level thread.
    Kernel-level threads have more overhead associated
    with them, but tend to have better scheduling
    characteristics, particularly on multi-processor systems.  Kernel-level
    threads may not be supported on some platforms and may be the default
    on others.  Hence, this option is advisory, but every effort is made
    to honour it.
 */
int veThreadInit(VeThread *t, void *(*func)(void *), void *arg, int priority,
		 int flags);

/** function veThreadDestroy
    Destroys a thread and deallocates its associated resources.  It 
    is up to the application to ensure that the thread has finished
    execution before calling this function.
    
    @param t
    A pointer to the thread to destroy.
*/
void veThreadDestroy(VeThread *t);

/** function veThreadKill
    Forcibly halts execution of a thread.  There are no guarantees
    that the thread has left its context in a meaningful state. 
    Any application which terminates a thread in this fashion should
    be prepared to clean up anything it leaves behind.  After returning
    from this call, the specified thread is no longer active.

    @param t
    The thread to kill.
*/
void veThreadKill(VeThread *t);

/** function veThreadWait
    Stops the current thread until the specified thread has finished
    execution.  Upon return from this function, the specified thread
    is no longer executing code and may either be destroyed or
    re-initialized.

    @param t
    The thread to wait on.
*/
void veThreadWait(VeThread *t);

/** function veThrMutexCreate
    Creates a mutex.  A mutex is a lock that can be held by at most
    one thread at a time.  In its initial state, no thread holds
    the mutex.

    @returns
    A pointer to the newly created mutex.
*/
VeThrMutex *veThrMutexCreate();

/** function veThrMutexDestroy
    Destroys a previously created mutex.  It is up to the application
    to ensure that it is safe to destroy the mutex - i.e. that at
    most the current thread is holding the mutex and that no threads
    attempt any operations upon this mutex after destroying it.

    @param m
    The mutex to destroy.
*/
void veThrMutexDestroy(VeThrMutex *m);

/** function veThrMutexLock
    <p>Locks a mutex with the current thread.  If the mutex is being held 
    by another thread then the current thread will stop until there
    are no other threads holding the mutex and it can lock it.  When the
    function returns, the current thread is holding the mutex.  When
    a thread holds a mutex, no other thread can hold it, and other threads
    will stop if they attempt to lock this mutex.</p>
    <p>Recursive locks (i.e. attempting to lock a mutex when the current
    thread has already locked it) are not supported.  The effects of a
    recursive lock are undefined.</p>

    @param m
    The mutex to lock.
*/
void veThrMutexLock(VeThrMutex *m);

/** function veThrMutexUnlock
    <p>Unlocks a mutex.  The current thread must hold the mutex.
    When the function returns, the specified mutex is no longer held
    by the current thread.  It may or may not be held by another thread.
    </p>
    
    @param m
    The mutex to unlock.
*/
void veThrMutexUnlock(VeThrMutex *m);

/** function veThrCondCreate
    <p>Creates a condition variable.  A condition variable is an object
    upon which a thread can wait.  A thread will be woken up if the
    event associated with a condition variable occurs.  In its
    initial state, there are no threads waiting upon a condition variable.</p>
    
    @returns
    A pointer to the newly-created condition variable.
*/
VeThrCond *veThrCondCreate();

/** function veThrCondDestroy
    <p>Destroys a condition variable previously created with
    <code>veThrCondCreate</code>.  It is up to the application to ensure
    that it is safe to destroy the condition variable, i.e. that there are
    no threads waiting on the condition variable.</p>
    
    @param c
    The condition variable to destroy.
*/
void veThrCondDestroy(VeThrCond *c);

/** function veThrCondWait
    <p>Waits upon a condition variable.  The current thread will stop until
    the event associated with a condition variable takes place.</p>
    <p>A mutex is usually associated with a condition variable.  There
    must be <i>a</i> mutex held by the current thread before calling this
    function.  Precisely <i>which</i> mutex is up to the application.
    Upon entering this function, the mutex will be unlocked while the 
    current thread is stopped.  When the thread is woken up it will lock
    the mutex again.
    </p>

    @param c
    The condition variable to wait upon.
    
    @param m
    The mutex associated with this condition variable.  The current
    thread must be holding this mutex.  The mutex will be unlocked
    while the thread is waiting and will be locked again once it
    finishes waiting.
*/
void veThrCondWait(VeThrCond *c, VeThrMutex *m);

/** function veThrCondTimedWait
    <p>Similar to <code>veThrCondWait</code> except that a time-limit
    is put upon how long the thread will wait on the given condition
    variable.  If the time-limit is reached before the event associated
    with the condition variable occurs, then the thread will be re-lock 
    the given mutex and return.</p>

    @param c
    The condition variable to wait upon.

    @param m
    The mutex associated with this condition variable.  The current
    thread must be holding this mutex.  The mutex will be unlocked
    while the thread is waiting and will be locked again once it
    finishes waiting.

    @param ms
    The time-limit in milliseconds.  If this amount of time passes
    before the thread is woken up, then the thread will return as
    though it had been woken up.
*/
void veThrCondTimedWait(VeThrCond *c, VeThrMutex *m, long ms);

/** function veThrCondSignal
    <p>Signals that the event associated with a condition variable
    has occurred.  Wakes up one thread that is waiting on the
    condition variable.  That thread will then attempt to re-lock its
    mutex and return from its corresponding "wait" function call.
    If no threads are waiting on this condition variable, then this
    call has no effect.</p>
    
    @param c
    The condition variable on which to wake up threads.
*/
void veThrCondSignal(VeThrCond *c);

/** function veThrCondBcast
    <p>Signals that the event associated with a condition variable
    has occurred.  Wakes up <i>all</i> threads that are waiting on the
    condition variable.
    If no threads are waiting on this condition variable, then this
    call has no effect.</p>
    
    @param c
    The condition variable on which to wake up threads.
*/
void veThrCondBcast(VeThrCond *c);

/** function veThrInitDelayGate
    <p>Initializes the delay gate.  Must be called before anything enters
    the delay gate.
*/
void veThrInitDelayGate(void);

/** function veThrDelayGate
    <p>Provided for threads that may be created during program initialization
    but which should not run until later.  Any such thread should call this
    function.  This function will not return until the 
    <code>veThrReleaseDelayed()</code> function is called from elsewhere in
    the program.
*/
void veThrDelayGate(void);

/** function veThrReleaseDelayed
    <p>Allows threads that are waiting in the delay gate to continue.
    After this function is called, the gate is considered open and any
    further threads that call <code>veThrDelayGate()</code> will not
    be stopped.
*/
void veThrReleaseDelayed(void);

/** function veThreadInitDelayed
    <p>This has the same effect as veThreadInit, except that actual
    instantiation of the thread will be delayed until the delay gate
    has been opened (by a call to <code>veThrReleaseDelayed()</code>).
    This allows threads to be setup but not actually created until needed.
    This approach helps on platforms with unusual thread characteristics 
    (e.g. Linux) and helps stability with multiple-process renderers.</p>
    <p>In general, all device drivers should use this interface instead
    of the <code>veThrDelayGate()</code> call.</p>
    <p>If the delay gate has already been released then this call has
    the identical effect as a call to <code>veThreadInit()</code>.
    For the details of the effects of the arguments, see 
    <code>veThreadInit()</code>.  Note that there is no argument that
    allows you to retrieve the id of a delayed thread.
    </p>
*/
int veThreadInitDelayed(void *(*func)(void *), void *arg, 
			int priority, int flags);

/* The following functions are not advertised outside of the
   library - they shouldn't be needed outside of the library */
void veThrMutexQuietLock(VeThrMutex *);
void veThrMutexQuietUnlock(VeThrMutex *);

#ifdef __cplusplus
}
#endif

#endif /* VE_THREAD_H */
