<html>
<head>
<title>File: nid.h</title>
</head>
<body>
<h1>File: nid.h</h1>
<h2>Contents</h2>
<ul>
<li><a href="#sect_0"><b>Data Types</b></a></li>
<li><a href="#sect_1"><b>Client Function-Specific Calls</b></a></li>
<li><a href="#sect_2"><b>Low-Level Calls</b></a></li>
</ul>


<p>
    <p>NID (Network Input Device) is a simple protocol for integrating remote
    devices into a VE world.  The NID library is separate from the VE library
    and can be used separately - i.e. there are no dependencies upon the
    VE code itself.  The NID library uses the "veclock" library.

    <p>NID nominally uses TCP to deliver data, although its protocol could be
    easily adapted to any serial transport with reliable delivery.  By default
    NID runs on port 1138 although it can potentially run anywhere.  NID 
    follows a similar scheme to VE input devices.  A NID server provides any
    number of devices.  A device is made up of some number of elements.  Each
    element has one of the following types:
    <ul>
    <li><b>TRIGGER</b> - a "single-shot" switch.  There is no state information.
    A trigger is equivalent to saying "something happened".
    <li><b>SWITCH</b> - a two-state switch.  A switch is always in either an
    active (non-zero value) or inactive state (zero value).
    <li><b>VALUATOR</b> - an element that can have a range of values
    represented as a real number.  A valuator can either be bounded (i.e.
    minimum and maximum values specified) or unbounded (minimum and maximum
    both declared as 0.0 - no limit on values).  For a bounded valuator,
    a NID server must never return a value outside of those limits.  How
    a NID server accomplishes this (e.g. rejection of data or clamping) is
    implementation-specific.  An example of a bounded valuator would be a
    steering wheel - there is limit to how far you can turn the wheel.
    An example of an unbounded valuator would be the integration of a
    bicycle wheel.
    <li><b>VECTOR</b> - some number of valuators that are associated together.
    A vector has a fixed size.  If any valuators in that vector change, then
    the entire vector is reported as having changed.  Vectors are used where
    the data reported by the input device is multi-dimensional and those 
    dimensions are interdependent (e.g. a head-tracker) and reporting such
    changes independently would be erroneous.  Valuators in a vector can
    be bounded or unbounded independently of the limits on other valuators
    in the same vector.
    <li><b>KEYBOARD</b> - a special case of a collection of switches.  Each
    individual button is not reported.  In addition to reporting a state
    change, the index of the button on the keyboard for which the state change
    occurred is also reported.  This index corresponds to a value defined in
    the <code>nid_keysym.h</code> header file.
    </ul>

    <p>The NID protocol in general terms requires that both ends initially
    send a handshake packet upon connecting.  The handshake packet contains
    the protocol version (major and minor revision) that each end speaks.
    If an end is happy with the offered protocol, it should send an "ack"
    packet.  If not, then it should send a "nak" packet.  Then, it should
    wait for the other end's response to the handshake.  After receiving
    the response, if the end had either sent a "nak" in response to the
    handshake, or received a "nak", it should close the connection.  In
    other words, if either side does not accept the handshake, both sides
    should close the connection.

    <p>By default a NID server should send no data.  It is up to the client
    to either poll the state of a device, or request that the server send 
    data when the state of the input device changes.  There is some support
    for throttling the reporting of device changes to avoiding queueing
    up too many changes and thus hurting the latency of input.

    <p>When data is sent over the wire, it is sent in "network-order"
    byte ordering (big-endian).  Real values are sent in their IEEE
    binary format (again using big-endian byte ordering).  The following
    data-types are defined as abstractions:
    <ul>
    <li><code>nid_uint32</code> - an unsigned 32-bit integer
    <li><code>nid_int32</code> - a signed 32-bit integer
    <li><code>nid_real</code> - a 32-bit real number in IEEE format.  On
    most systems, this is just "float".
    </ul>

    <p>Every client-side function is also represented as a library call,
    so clients using this library should not need to explictily send and
    receive packets.

<p>
<a name="sect_0"></a><h2>Data Types</h2>
<p>
<a name="struct_NidHeader"></a><p><em>Structure:</em> <b>NidHeader</b>
<blockquote>
    All NID packets begin with this header.  Many packets are followed by
    a payload (see the <code>NidPacket</code> structure).

<pre>
typedef struct nid_header {</pre><p>
<p><b>size</b> - 
      The size of the packet minus 4 bytes (the size of the "size" field).
  
<pre>
  nid_uint32 size;</pre><pre></pre><p>
<p><b>request</b> - 
      A number identifying a particular request.  The existing servers do
      not support interleaving of requests, but may in the future.  This
      field is also used to distinguish between state updates and responses
      to an explicit request.
  
<pre>
  nid_uint32 request;</pre><pre></pre><p>
<p><b>type</b> - 
      The type of the packet.  The types are defined by the <code>NID_PKT_*</code>
      macros in the <code>nid.h</code> header file.
  
<pre>
  nid_uint32 type;</pre><pre>
} NidHeader;</pre></blockquote>
<p>
<a name="struct_NidTimeSynch"></a><p><em>Structure:</em> <b>NidTimeSynch</b>
<blockquote>
    Used for synchronizing a Nid server's clock with the client's.  The
    string format for the time is same as is used in the "veclock" library.

<pre>
typedef struct nid_time_synch {
  nid_uint32 refpt;
  char absolute[NID_DEVICE_STR_SZ];
} NidTimeSynch;</pre></blockquote>
<p>
<a name="struct_NidDeviceFunc"></a><p><em>Structure:</em> <b>NidDeviceFunc</b>
<blockquote>
    An extended function call.  Allows for non-standard special functions to
    be accessed on a particular device.  This should only be used for
    cases which are not covered by the NID protocol itself and where such
    functionality is desperately needed.  In other words, the use of 
    special function calls is strongly discouraged.

<pre>
typedef struct nid_device_func {</pre><p>
<p><b>devid</b> - 
      The identifier of the device.
  
<pre>
  nid_uint32 devid;</pre><pre></pre><p>
<p><b>func</b> - 
      The name of the special function to be called.  No pre-defined names
      exist.  These are all specific to the device in question and should
      be considered non-portable.
  
<pre>
  char func[NID_DEVICE_STR_SZ];</pre><pre></pre><p>
<p><b>args</b> - 
      Arguments to the special function.  The arguments are represented as
      a string.  The size of the arguments is limited by the size of a string
      in NID.
  
<pre>
  char args[NID_DEVICE_STR_SZ];</pre><pre>
} NidDeviceFunc;</pre></blockquote>
<p>
<a name="struct_NidDeviceResp"></a><p><em>Structure:</em> <b>NidDeviceResp</b>
<blockquote>
    The response to a special function call.  This is effectively an "ack"
    with extra data.  If a function call fails, then a regular NID "nak"
    packet should be sent.

<pre>
typedef struct nid_device_resp {
  nid_uint32 code;
  char data[NID_DEVICE_STR_SZ];
} NidDeviceResp;</pre></blockquote>
<p>
<a name="struct_NidHandshake"></a><p><em>Structure:</em> <b>NidHandshake</b>
<blockquote>
    A handshake payload which consists of the major and minor revisions
    of the protocol.  These should be defined in the <code>nid.h</code>
    header file as the <code>NID_PROTO_MAJOR</code> and <code>NID_PROTO_MINOR</code>
    macros.

<pre>
typedef struct nid_handshake {
  nid_uint32 protocol_major;
  nid_uint32 protocol_minor;
} NidHandshake;</pre></blockquote>
<p>
<a name="struct_NidNak"></a><p><em>Structure:</em> <b>NidNak</b>
<blockquote>
    A non-acknowledgement.  This response indicates that a command failed.

<pre>
typedef struct nid_nak {</pre><p>
<p><b>reason</b> - 
      Optionally a command may include a numeric code indicating why
      it failed.  There are no generally defined values for the reason -
      this is specific to each command.
  
<pre>
  nid_uint32 reason;</pre><pre>
} NidNak;</pre></blockquote>
<p>
<a name="struct_NidEnumElements"></a><p><em>Structure:</em> <b>NidEnumElements</b>
<blockquote>
    A request to return a list of all elements of a particular device.

<pre>
typedef struct nid_enum_elements {</pre><p>
<p><b>id</b> - 
      The numeric identifier of the device for which you are requesting
      data.
  
<pre>
  nid_uint32 id;</pre><pre>
} NidEnumElements;</pre></blockquote>
<p>
<a name="struct_NidElementId"></a><p><em>Structure:</em> <b>NidElementId</b>
<blockquote>
    A structure identifying a specific element of a specific device 
    using numeric identifiers.

<pre>
typedef struct {
  nid_uint32 devid;
  nid_uint32 elemid;
} NidElementId;</pre></blockquote>
<p>
<a name="struct_NidElementRequests"></a><p><em>Structure:</em> <b>NidElementRequests</b>
<blockquote>
    An array of elements identified using NidElementId structures.
    This payload is used to request details of specific device elements.

<pre>
typedef struct nid_element_requests {
  nid_uint32 num_requests;
  NidElementId *requests;
} NidElementRequests;</pre></blockquote>
<p>
<a name="struct_NidFindDevice"></a><p><em>Structure:</em> <b>NidFindDevice</b>
<blockquote>
    A device name and type specifier used for locating devices
    on the server.  These specifiers are either the name of a particular
    device or type, or an asterisk "*" to denote a wildcard.

<pre>
typedef struct nid_find_device {
  char name[NID_DEVICE_STR_SZ];
  char type[NID_DEVICE_STR_SZ];
} NidFindDevice;</pre></blockquote>
<p>
<a name="struct_NidDeviceInfo"></a><p><em>Structure:</em> <b>NidDeviceInfo</b>
<blockquote>
    The basic information of a device returned in response to a FIND_DEVICE
    or ENUM_DEVICES call.

<pre>
typedef struct nid_device_info {</pre><p>
<p><b>devid</b> - 
      The numeric identifier of the device.  This will be unique within
      a particular server.  It is used as an argument to other calls to
      identifiy the device.
   
<pre>
  nid_uint32 devid;</pre><pre></pre><p>
<p><b>name</b> - 
      The name of the device.  If the name of the device is larger than the
      given space in the string, the name will be truncated to fit.  This
      name is unique within a particular server.
  
<pre>
  char name[NID_DEVICE_STR_SZ];</pre><pre></pre><p>
<p><b>type</b> - 
      The type of the device.  This is just a string identifying the class
      of the device.  There may be several devices on a server with the same
      type.  Types are not pre-defined in the protocol - they are specific
      to however a server chooses to report a type.  Servers should try to
      keep type names consistent.
  
<pre>
  char type[NID_DEVICE_STR_SZ];</pre><pre>
} NidDeviceInfo;</pre></blockquote>
<p>
<a name="struct_NidDeviceList"></a><p><em>Structure:</em> <b>NidDeviceList</b>
<blockquote>
    An array of NidDeviceInfo structures.

<pre>
typedef struct nid_device_list {
  nid_uint32 num_devices;
  NidDeviceInfo *devices;
} NidDeviceList;</pre></blockquote>
<p>
<a name="struct_NidElementInfo"></a><p><em>Structure:</em> <b>NidElementInfo</b>
<blockquote>
    The details of an element, excluding its current state.

<pre>
typedef struct nid_elem_info {</pre><p>
<p><b>name</b> - 
      The name of the element.  This is unique within a particular device
      but not necessarily between devices - e.g. two devices may have elements
      with the same name.
  
<pre>
  char name[NID_DEVICE_STR_SZ];</pre><pre></pre><p>
<p><b>elemid</b> - 
      A numeric identifier for this element.  This identifier is unique
      within a particular device.
  
<pre>
  nid_uint32 elemid;</pre><pre></pre><p>
<p><b>type</b> - 
      The type of the element (i.e. trigger, switch, valuator, etc.).
  
<pre>
  nid_uint32 type;</pre><pre></pre><p>
<p><b>vsize</b> - 
      If the element is a vector, the size of the vector.  This must not
      change once defined.  Each vector can have its own size, but a vector
      cannot be resized during any particular client's connection.  A
      hard-coded constant (<code>NID_VECTOR_MAX_SZ</code>) limits the
      maximum size of a vector.  If this constant is changed then the
      protocol number should be changed to avoid problems with programs
      expecting a different maximum vector size.
  
<pre>
  nid_uint32 vsize;</pre><pre></pre><p>
<p><b>min,max</b> - 
      The bounds on valuators and vectors.  For a valuator, only the first
      item in the array (index 0) is used.  If both min and max are 0.0 for
      a valuator, or for a particular offset in a vector, then that particular
      valuator is unbounded - that is, no explicit limits are set on its
      possible value.
  
<pre>
  nid_real   min[NID_VECTOR_MAX_SZ], max[NID_VECTOR_MAX_SZ];</pre><pre>
} NidElementInfo;</pre></blockquote>
<p>
<a name="struct_NidElementList"></a><p><em>Structure:</em> <b>NidElementList</b>
<blockquote>
    An array of NidElementList structures for a particular device.  
    This is sent in response to an ENUM_ELEMENTS request.

<pre>
typedef struct nid_elem_list {
  nid_uint32 devid;
  nid_uint32 num_elems;
  NidElementInfo *elements;
} NidElementList;</pre></blockquote>
<p>
<a name="struct_NidElementState"></a><p><em>Structure:</em> <b>NidElementState</b>
<blockquote>
    The state of a particular element.  The value of the type field determines
    which of the representations of the "data" union is valid.

<pre>
typedef struct nid_elem_state {</pre><p>
<p><b>timestamp</b> - 
      The time at which this element state came into being.  This is relative
      to the server's clock which can be synchronized through NID.
      (See the <code>nidTimeSynch()</code> command.)  Otherwise, this value
      is interpreted as a value returned from the <code>veClock()</code>
      command from the veclock library.  This value is in milliseconds.
  
<pre>
  nid_uint32 timestamp;</pre><pre></pre><p>
<p><b>devid</b> - 
      The numeric identifier of the device.
  
<pre>
  nid_uint32 devid;</pre><pre></pre><p>
<p><b>elemid</b> - 
      The numeric identifier of the element.
  
<pre>
  nid_uint32 elemid;</pre><pre></pre><p>
<p><b>type</b> - 
      The type of the element.  This is provided as a convenience.  Its
      type must always match the real type of the element.
  
<pre>
  nid_uint32 type;</pre><pre></pre><p>
<p><b>data</b> - 
      The actual state of the element.  Note the use of "switch_" instead
      of "switch" to avoiding clashing with the reserved word "switch" in C.
      For the keyboard element, "code" indicates to which key the given state
      applies.  Key codes are defined in the <code>nid_keysym.h</code> header
      file.
  
<pre>
  union {
    nid_uint32 switch_;
    nid_real valuator;
    struct {
      nid_uint32 code;
      nid_uint32 state;} keyboard;
    struct {
      nid_uint32 size;
      nid_real data[NID_VECTOR_MAX_SZ];} vector;} data;</pre><pre>
} NidElementState;</pre></blockquote>
<p>
<a name="struct_NidStateList"></a><p><em>Structure:</em> <b>NidStateList</b>
<blockquote>
    An array of element states.  Sent in response to a poll or as a 
    requested automatic update.

<pre>
typedef struct nid_state_list {
  nid_uint32 num_states;
  NidElementState *states;
} NidStateList;</pre></blockquote>
<p>
<a name="struct_NidEventSink"></a><p><em>Structure:</em> <b>NidEventSink</b>
<blockquote>
    A string representing a new place to which to deliver events.
    See <code>nidSetEventSink()</code>.

<pre>
typedef struct nid_event_sink {
  char sink[NID_SINK_STR_SZ];
} NidEventSink;</pre></blockquote>
<p>
<a name="struct_NidValue"></a><p><em>Structure:</em> <b>NidValue</b>
<blockquote>
    A server-specific value.  The only currently defined value is 
    <code>NID_VALUE_REFRESH_RATE</code> which determines the maximum
    rate at which the server will send data.

<pre>
typedef struct nid_value {</pre><p>
<p><b>id</b> - 
      A numeric identifier for the value.
  
<pre>
  nid_uint32 id;</pre><pre></pre><p>
<p><b>value</b> - 
      The value itself.
  
<pre>
  nid_int32  value;</pre><pre>
} NidValue;</pre></blockquote>
<p>
<a name="struct_NidPacket"></a><p><em>Structure:</em> <b>NidPacket</b>
<blockquote>
    An actual packet.  Although a packet is sent as a contiguous piece
    of data, it is represented in the library as a header plus a pointer
    to a payload.

<pre>
typedef struct nid_packet {
  NidHeader header;
  void *payload;
} NidPacket;</pre></blockquote>
<p>
<a name="sect_1"></a><h2>Client Function-Specific Calls</h2>
<p>
<a name="function_nidOpen"></a><p><em>Function:</em> <b>nidOpen</b>
<blockquote>
<pre>
int nidOpen(char *host, int port);</pre>    Opens a connection to a NID server and attempts a handshake.
    
<p><b>host</b> - 
    The name of the host to which to connect.  This must be specified.
<p><b>port</b> - 
    The port number to connect to on the remote host.  If this value is
    less than or equal to 0 then the default NID port is used.
<p><i>Returns:</i> 
    If the connection or the handshake fails, then a value less than 0
    is returned.  In this case, the connection is not open.
    Otherwise a value greater than or equal to 0 is returned.  This is
    an identifier for this particular connection and must be specified
    as an argument to other calls to the client library.

</blockquote>
<p>
<a name="function_nidRegister"></a><p><em>Function:</em> <b>nidRegister</b>
<blockquote>
<pre>
int nidRegister(int fd);</pre>    Registers a given file descriptor as a NID connection.  The effect
    is the same as the <code>nidOpen()</code> call except that the connection
    is established elsewhere.  This function will attempt a handshake on
    the given connection.
    
<p><b>fd</b> - 
    The file descriptor upon which to attempt a NID connection.
<p><i>Returns:</i> 
    If the handshake fails, then a value less than 0 is returned.
    The given file descriptor is not closed or otherwise affected.
    If the handshake succeeds then a value greater than or equal to 0 is
    returned.  This is an identifier for this particular connection and
    must be specified as an argument to other calls to the client library.

</blockquote>
<p>
<a name="function_nidClose"></a><p><em>Function:</em> <b>nidClose</b>
<blockquote>
<pre>
void nidClose(int conn);</pre>    Closes an existing NID connection returned from either <code>nidOpen()</code>
    or <code>nidRegister()</code>.

<p><b>conn</b> - 
    The identifier of the connection to close as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.

</blockquote>
<p>
<a name="function_nidLastError"></a><p><em>Function:</em> <b>nidLastError</b>
<blockquote>
<pre>
int nidLastError(int conn);</pre>    Returns the last error state of a NID connection.  A value of 0 indicates 
    that no error state has been seen, a value of -1 indicates an internal 
    error, and any other value is a value returned as a reason in a "nak" 
    packet.

<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
<p><i>Returns:</i> 
    The last error state of the NID connection identified by <b>conn</b>.

</blockquote>
<p>
<a name="function_nidLastErrorMsg"></a><p><em>Function:</em> <b>nidLastErrorMsg</b>
<blockquote>
<pre>
char *nidLastErrorMsg(int conn);</pre>    The text associated with the last error state (see <code>nidLastError()</code>).
    
<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
<p><i>Returns:</i> 
    The last error text.  A valid pointer to a null-terminated string is
    always returned, although the text may not be meaningful if no error
    state has been seen.

</blockquote>
<p>
<a name="function_nidEnumDevices"></a><p><em>Function:</em> <b>nidEnumDevices</b>
<blockquote>
<pre>
NidDeviceList *nidEnumDevices(int conn);</pre>    Retrieves a list of all devices on a NID server.
    
<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
<p><i>Returns:</i> 
    An array of device identifiers as a <code>NidDeviceList</code> structure.
    This array must be freed with <code>nidFreeDeviceList()</code> when the
    client is done with it.

</blockquote>
<p>
<a name="function_nidEnumElements"></a><p><em>Function:</em> <b>nidEnumElements</b>
<blockquote>
<pre>
NidElementList *nidEnumElements(int conn, int dev);</pre>    Retrieves a list of elements for a given device.

<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
<p><b>dev</b> - 
    The numeric identifier of the device for which to return the list of
    elements.
<p><i>Returns:</i> 
    An array of element identifiers as a <code>NidElementList</code>
    structure.  This array must be freed with <code>nidFreeElementList()</code>
    when the client is done with it.

</blockquote>
<p>
<a name="function_nidQueryElements"></a><p><em>Function:</em> <b>nidQueryElements</b>
<blockquote>
<pre>
NidStateList *nidQueryElements(int conn, NidElementId *ids, int nids);</pre>    Retrieves the state of the specified set of elements.  The elements can
    be from different devices or the same device.
    
<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
<p><b>ids</b> - 
    An array of <code>NidElementId</code> structures identifying the elements
    which should be queried.
<p><b>nids</b> - 
    The number of structures in the array given by <b>ids</b>.
<p><i>Returns:</i> 
    An array of element states as a <code>NidStateList</code> structure.
    This array must be freed with <code>nidFreeStateList()</code> when the
    client is done with it.

</blockquote>
<p>
<a name="function_nidListenElements"></a><p><em>Function:</em> <b>nidListenElements</b>
<blockquote>
<pre>
int nidListenElements(int conn, NidElementId *ids, int nids);</pre>    Requests that the NID server automatically send updates for the given
    elements.

<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
<p><b>ids</b> - 
    An array of <code>NidElementId</code> structures identifying the elements
    which should be listened to.
<p><b>nids</b> - 
    The number of structures in the array given by <b>ids</b>.
<p><i>Returns:</i> 
    A value of 0 on success, and a non-zero value on failure.

</blockquote>
<p>
<a name="function_nidIgnoreElements"></a><p><em>Function:</em> <b>nidIgnoreElements</b>
<blockquote>
<pre>
int nidIgnoreElements(int conn, NidElementId *ids, int nids);</pre>    Requests that the NID server should stop sending automatic updates for 
    the given elements.

<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
<p><b>ids</b> - 
    An array of <code>NidElementId</code> structures identifying the elements
    which should be ignored.
<p><b>nids</b> - 
    The number of structures in the array given by <b>ids</b>.
<p><i>Returns:</i> 
    A value of 0 on success, and a non-zero value on failure.

</blockquote>
<p>
<a name="function_nidFindDevice"></a><p><em>Function:</em> <b>nidFindDevice</b>
<blockquote>
<pre>
NidDeviceList *nidFindDevice(int conn, char *name, char *type);</pre>    Attempts to locate a particular device or set of devices on the server.
    
<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
<p><b>name</b> - 
    The exact name of the device or "*" to indicate any device.
<p><b>type</b> - 
    The exact type of the device or "*" to indicate any type of device.
<p><i>Returns:</i> 
    An array of matching devices as a <code>NidDeviceList</code> structure.
    This array must be freed with <code>nidFreeDeviceList()</code> when the
    client is through with it.

</blockquote>
<p>
<a name="function_nidNextEvents"></a><p><em>Function:</em> <b>nidNextEvents</b>
<blockquote>
<pre>
NidStateList *nidNextEvents(int conn, int wait);</pre>    Reads the next automatic update of events on the given connection.
    If there are none currently available, this function will block until
    events are available, depending upon the value of the "wait" parameter.

<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
    
<p><b>wait</b> - 
    This parameter affects how the function behaves if there are no events
    currently available.  If 0, then the function returns immediately.  If
    non-zero, then the function will wait until events are available and
    return the first packet of events.

<p><i>Returns:</i> 
    An array of element states as a <code>NidStateList</code> structure.
    This array must be freed with <code>nidFreeStateList()</code> when the
    client is done with it.  If no events are available and wait is 0, then
    <code>NULL</code> is returned.

</blockquote>
<p>
<a name="function_nidSetValue"></a><p><em>Function:</em> <b>nidSetValue</b>
<blockquote>
<pre>
int nidSetValue(int conn, nid_uint32 id, nid_int32 val);</pre>    Sets a server-specific configuration value.  Currently the only defined 
    value is
    <code>NID_VALUE_REFRESH_RATE</code>.  This is a value in Hz which
    indicates the maximum rate at which updates should be automatically
    sent to the client.  If events are generated on the server faster than
    the refresh rate, then the events will be batched and delayed to meet
    the refresh rate.  A higher refresh rate will reduce the latency of
    input but increase the overhead of communication.  High refresh rates
    may increase latency by overwhelming communication between the client
    and server.

<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
<p><b>id</b> - 
    The numeric identifier of the value to set.  Currently the only
    defined value is <code>NID_VALUE_REFRESH_RATE</code>.  Other servers
    may define other values.

<p><b>val</b> - 
    The new value.  Currently values can only be integers.
    
<p><i>Returns:</i> 
    A value of 0 on success, and a non-zero value on failure.

</blockquote>
<p>
<a name="function_nidGetValue"></a><p><em>Function:</em> <b>nidGetValue</b>
<blockquote>
<pre>
int nidGetValue(int conn, nid_uint32 id, nid_int32 *val_ret);</pre>    Retrieves a server-specific configuration value.  See
    <code>nidSetValue()</code> for details of known value identifiers.
    
<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
<p><b>id</b> - 
    The numeric identifier of the value to set.  Currently the only
    defined value is <code>NID_VALUE_REFRESH_RATE</code>.  Other servers
    may define other values.
<p><b>val_ret</b> - 
    A pointer to an integer where the retrieved value will be stored.
    Currently values can only be integers.    

<p><i>Returns:</i> 
    A value of 0 on success, and a non-zero value on failure.
 
</blockquote>
<p>
<a name="function_nidTimeSynch"></a><p><em>Function:</em> <b>nidTimeSynch</b>
<blockquote>
<pre>
void nidTimeSynch(int conn, nid_uint32 ref, char *absolute);</pre>    Provides a clock reference point to the NID server.  The NID server
    should use this reference point to adjust the clock it uses to
    generate timestamps on automatically reported events.
    The default NID server just passes this information to its
    instance of the veclock library.

<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
<p><b>ref</b> - 
    The reference point in clock time which the given string
    represents.
<p><b>absolute</b> - 
    The wall clock time to which the reference point corresponds.
    The format of this string is the same as is used in the veclock
    library.

</blockquote>
<p>
<a name="function_nidCompressEvents"></a><p><em>Function:</em> <b>nidCompressEvents</b>
<blockquote>
<pre>
int nidCompressEvents(int conn);</pre>    Requests that any events on the server should be buffered and
    compressed by the server.  Events are compressed by combining adjacent
    valuator events ("adjacent" meaning that they are separated only by
    valuator events from any device/element) into a single event.  Instead
    of streaming events, the server will only send an <code>EVENTS_AVAIL</code>
    packet when it has new events in its buffer.  The stored events can be
    retrieved using a <code>DUMP_EVENTS</code> request.
    
<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
    
<p><i>Returns:</i> 
    0 if the request is sucessful, non-zero otherwise.

</blockquote>
<p>
<a name="function_nidUncompressEvents"></a><p><em>Function:</em> <b>nidUncompressEvents</b>
<blockquote>
<pre>
int nidUncompressEvents(int conn);</pre>    Requests that the server no longer compress events and return them
    as they occur (i.e. in old-fashioned streaming mode).  See
    <code>nidCompressEvents()</code>.
    
<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.

<p><i>Returns:</i> 
    0 if the request is sucessful, non-zero otherwise.

</blockquote>
<p>
<a name="function_nidDumpEvents"></a><p><em>Function:</em> <b>nidDumpEvents</b>
<blockquote>
<pre>
NidStateList *nidDumpEvents(int conn);</pre>    Requests that the server send any compressed events it may have buffered.
    The response will be an <code>ELEMENT_STATES</code> packet.
    
<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.

<p><i>Returns:</i> 
    The set of states returned, or <code>NULL</code> if there is an
    error, or no states are available.

</blockquote>
<p>
<a name="function_nidSetEventSink"></a><p><em>Function:</em> <b>nidSetEventSink</b>
<blockquote>
<pre>
int nidSetEventSink(int conn, char *sink);</pre>    Requests that the server redirect any automatically delievered events
    to the given connection, described as a string.
    Control remains with the original connection.  This will redirect
    all automatic updates to the new sink.  The following strings are
    recognized - others may be supported on specific implementations.
    <ul>
    <li><b>default</b> - deliver events on control connection</li>
    <li><b>tcp</b> <i>host</i> <i>port</i> - make a new TCP connection 
    to the given host and port</li>
    <li><b>udp</b> <i>host</i> <i>port</i> - make a new UDP connection
    to the given host and port</li>
    </ul>

<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
    
<p><b>sink</b> - 
    A string describing the new sink to which the server should send events.

<p><i>Returns:</i> 
    0 if the request is sucessful, non-zero otherwise.

</blockquote>
<p>
<a name="function_nidChangeTransport"></a><p><em>Function:</em> <b>nidChangeTransport</b>
<blockquote>
<pre>
int nidChangeTransport(int conn, char *tport);</pre>    This is a higher-level wrapper for <code>nidSetEventSink()</code> which
    creates the necessary network objects internally.  Most client code
    will use this function instead of <code>nidSetEventSink()</code>.
    
<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.

<p><b>tport</b> - 
    One of
    <ul>
    <li>"default" - use the control connection</li>
    <li>"tcp" - use a new TCP connection</li>
    <li>"udp" - use a new UDP connection</li>
    </ul>

<p><i>Returns:</i> 
    0 if the request is sucessful, non-zero otherwise.

</blockquote>
<p>
<a name="function_nidProcessTransport"></a><p><em>Function:</em> <b>nidProcessTransport</b>
<blockquote>
<pre>
int nidProcessTransport(int conn, char *tport);</pre>    Called on the server side to reconfigure a connection for the
    requested event transport.  Client code should never call this.
    
<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.

<p><b>tport</b> - 
    The transport/sink string sent by the client in a 
    <code>NID_PKT_SET_EVENT_SINK</code> packet.
    
<p><i>Returns:</i> 
    0 if the request is sucessful, non-zero otherwise.

</blockquote>
<p>
<a name="function_nidFreeDeviceList"></a><p><em>Function:</em> <b>nidFreeDeviceList</b>
<blockquote>
<pre>
void nidFreeDeviceList(NidDeviceList *l);</pre>    Frees memory associated with a NidDeviceList structure allocated by
    the NID library.  After freeing, the passed pointer will no longer be
    valid and should not be de-referenced.
    
<p><b>l</b> - 
    The structure to free.

</blockquote>
<p>
<a name="function_nidFreeElementList"></a><p><em>Function:</em> <b>nidFreeElementList</b>
<blockquote>
<pre>
void nidFreeElementList(NidElementList *l);</pre>    Frees memory associated with a NidElementList structure allocated by
    the NID library.  After freeing, the passed pointer will no longer be
    valid and should not be de-referenced.
    
<p><b>l</b> - 
    The structure to free.

</blockquote>
<p>
<a name="function_nidFreeStateList"></a><p><em>Function:</em> <b>nidFreeStateList</b>
<blockquote>
<pre>
void nidFreeStateList(NidStateList *l);</pre>    Frees memory associated with a NidStateList structure allocated by
    the NID library.  After freeing, the passed pointer will no longer be
    valid and should not be de-referenced.
    
<p><b>l</b> - 
    The structure to free.

</blockquote>
<p>
<a name="function_nidFreeElementRequests"></a><p><em>Function:</em> <b>nidFreeElementRequests</b>
<blockquote>
<pre>
void nidFreeElementRequests(NidElementRequests *l);</pre>    Frees memory associated with a NidElementRequests structure allocated by
    the NID library.  After freeing, the passed pointer will no longer be
    valid and should not be de-referenced.
    
<p><b>l</b> - 
    The structure to free.

</blockquote>
<p>
<a name="function_nidFreePacket"></a><p><em>Function:</em> <b>nidFreePacket</b>
<blockquote>
<pre>
void nidFreePacket(NidPacket *p);</pre>    Frees a NidPacket structure and any payload associated with a packet.
    If you wish to preserve the payload of a packet, but free the packet 
    itself, save the pointer to the payload somewhere else and set the
    <code>payload</code> member of the packet structure to <code>NULL</code>
    before calling this function.

<p><b>p</b> - 
    The packet to free.

</blockquote>
<p>
<a name="sect_2"></a><h2>Low-Level Calls</h2>
<p>
<a name="function_nidReceivePacket"></a><p><em>Function:</em> <b>nidReceivePacket</b>
<blockquote>
<pre>
NidPacket *nidReceivePacket(int conn, int request);</pre>    Retrieves the next packet from the given connection.  This function
    generally only needs to be used by servers or clients that wish to
    access the library at a lower-level.  Where possible, clients should
    use the function-specific calls.

<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
<p><b>request</b> - 
    If this value is greater than or equal to 0, then incoming packets will
    be discarded until one arrives with a request field in its header that
    matches this parameter.  If this value is less than 0, then the next packet
    that arrives is returned regardless of its request field.
    <p>Please note that a request value of 0 is reserved for automatic
    event updates.

<p><i>Returns:</i> 
    A pointer to the decoded packet.  This structure needs to be freed with
    a call to <code>nidFreePacket</code> when the program is finished with it.

</blockquote>
<p>
<a name="function_nidTransmitPacket"></a><p><em>Function:</em> <b>nidTransmitPacket</b>
<blockquote>
<pre>
int nidTransmitPacket(int conn, NidPacket *pkt);</pre>    Transmits a packet over a NID connection.  This function takes care
    of any byte-ordering issues - the given packet should be in local
    machine byte-order.  This function generally only needs to be called
    by servers and clients who wish to access the library at a low-level.
    Where possible, clients should use the function-specific calls.

<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
<p><b>pkt</b> - 
    A pointer to the packet to transmit.
    
<p><i>Returns:</i> 
    0 on success, non-zero on failure.
 
</blockquote>
<p>
<a name="function_nidConnectionFd"></a><p><em>Function:</em> <b>nidConnectionFd</b>
<blockquote>
<pre>
int nidConnectionFd(int conn);</pre>    Returns the system file descriptor for the stream corresponding to the
    given NID connection.

<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
<p><i>Returns:</i> 
    The system file descriptor as an integer.  On UNIX-like systems this
    should always be a value greater than or equal to zero.

</blockquote>
<p>
<a name="function_nidEventFd"></a><p><em>Function:</em> <b>nidEventFd</b>
<blockquote>
<pre>
int nidEventFd(int conn);</pre>    Returns the system file descriptor for the stream corresponding to the
    given NID connection's transport for events.  This may or may not be
    same as the result returned by <code>nidConnectionFd()</code>.  All
    asynchronous events should be sent via this file descriptor.

<p><b>conn</b> - 
    The identifier of the connection as returned from either 
    <code>nidOpen()</code> or <code>nidRegister()</code>.
<p><i>Returns:</i> 
    The system file descriptor as an integer.  On UNIX-like systems this
    should always be a value greater than or equal to zero.

</blockquote>
<p>
<a name="function_nidLogToSyslog"></a><p><em>Function:</em> <b>nidLogToSyslog</b>
<blockquote>
<pre>
void nidLogToSyslog(int bool);</pre>    By default, NID logs any messages to the stream associated with
    stderr.  Optionally, NID can send messages to the system
    log (where available).

<p><b>bool</b> - 
    If non-zero, then any further messages will be sent to the system log.
    If zero, then any further messages will be sent to stderr.

</blockquote>

<h2>Index</h2>
<ul>
<li><a href="#function_nidChangeTransport">nidChangeTransport (function)</a></li>
<li><a href="#function_nidClose">nidClose (function)</a></li>
<li><a href="#function_nidCompressEvents">nidCompressEvents (function)</a></li>
<li><a href="#function_nidConnectionFd">nidConnectionFd (function)</a></li>
<li><a href="#function_nidDumpEvents">nidDumpEvents (function)</a></li>
<li><a href="#function_nidEnumDevices">nidEnumDevices (function)</a></li>
<li><a href="#function_nidEnumElements">nidEnumElements (function)</a></li>
<li><a href="#function_nidEventFd">nidEventFd (function)</a></li>
<li><a href="#function_nidFindDevice">nidFindDevice (function)</a></li>
<li><a href="#function_nidFreeDeviceList">nidFreeDeviceList (function)</a></li>
<li><a href="#function_nidFreeElementList">nidFreeElementList (function)</a></li>
<li><a href="#function_nidFreeElementRequests">nidFreeElementRequests (function)</a></li>
<li><a href="#function_nidFreePacket">nidFreePacket (function)</a></li>
<li><a href="#function_nidFreeStateList">nidFreeStateList (function)</a></li>
<li><a href="#function_nidGetValue">nidGetValue (function)</a></li>
<li><a href="#function_nidIgnoreElements">nidIgnoreElements (function)</a></li>
<li><a href="#function_nidLastError">nidLastError (function)</a></li>
<li><a href="#function_nidLastErrorMsg">nidLastErrorMsg (function)</a></li>
<li><a href="#function_nidListenElements">nidListenElements (function)</a></li>
<li><a href="#function_nidLogToSyslog">nidLogToSyslog (function)</a></li>
<li><a href="#function_nidNextEvents">nidNextEvents (function)</a></li>
<li><a href="#function_nidOpen">nidOpen (function)</a></li>
<li><a href="#function_nidProcessTransport">nidProcessTransport (function)</a></li>
<li><a href="#function_nidQueryElements">nidQueryElements (function)</a></li>
<li><a href="#function_nidReceivePacket">nidReceivePacket (function)</a></li>
<li><a href="#function_nidRegister">nidRegister (function)</a></li>
<li><a href="#function_nidSetEventSink">nidSetEventSink (function)</a></li>
<li><a href="#function_nidSetValue">nidSetValue (function)</a></li>
<li><a href="#function_nidTimeSynch">nidTimeSynch (function)</a></li>
<li><a href="#function_nidTransmitPacket">nidTransmitPacket (function)</a></li>
<li><a href="#function_nidUncompressEvents">nidUncompressEvents (function)</a></li>
<li><a href="#struct_NidDeviceFunc">NidDeviceFunc (struct)</a></li>
<li><a href="#struct_NidDeviceInfo">NidDeviceInfo (struct)</a></li>
<li><a href="#struct_NidDeviceList">NidDeviceList (struct)</a></li>
<li><a href="#struct_NidDeviceResp">NidDeviceResp (struct)</a></li>
<li><a href="#struct_NidElementId">NidElementId (struct)</a></li>
<li><a href="#struct_NidElementInfo">NidElementInfo (struct)</a></li>
<li><a href="#struct_NidElementList">NidElementList (struct)</a></li>
<li><a href="#struct_NidElementRequests">NidElementRequests (struct)</a></li>
<li><a href="#struct_NidElementState">NidElementState (struct)</a></li>
<li><a href="#struct_NidEnumElements">NidEnumElements (struct)</a></li>
<li><a href="#struct_NidEventSink">NidEventSink (struct)</a></li>
<li><a href="#struct_NidFindDevice">NidFindDevice (struct)</a></li>
<li><a href="#struct_NidHandshake">NidHandshake (struct)</a></li>
<li><a href="#struct_NidHeader">NidHeader (struct)</a></li>
<li><a href="#struct_NidNak">NidNak (struct)</a></li>
<li><a href="#struct_NidPacket">NidPacket (struct)</a></li>
<li><a href="#struct_NidStateList">NidStateList (struct)</a></li>
<li><a href="#struct_NidTimeSynch">NidTimeSynch (struct)</a></li>
<li><a href="#struct_NidValue">NidValue (struct)</a></li>
</ul>
</body>
</html>
